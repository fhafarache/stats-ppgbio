[
  {
    "objectID": "c10_GLMs.html",
    "href": "c10_GLMs.html",
    "title": "10  Modelos lineares generalizados (GLMs)",
    "section": "",
    "text": "10.1 Desvio (deviance)\nA medida da discrepância entre os valores ajustados pelo modelo e os valores observados nos GLM é chamada de desvio ou deviance. Esta medida é baseada na comparação da verossimilhança entre o modelo criado e um modelo saturado, onde é criado um modelo que ajusta os dados perfeitamente.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos lineares generalizados (GLMs)</span>"
    ]
  },
  {
    "objectID": "c10_GLMs.html#glms-para-dados-de-contagem",
    "href": "c10_GLMs.html#glms-para-dados-de-contagem",
    "title": "10  Modelos lineares generalizados (GLMs)",
    "section": "10.2 GLMs para dados de contagem",
    "text": "10.2 GLMs para dados de contagem\nVamos analisar o conjunto de dados riqueza, que inclui a riqueza de espécies em parcelas, relacionadas ao índice de luminosidade e biomassa de serrapilheira. Primeiro vamos limportar os dados, verificar sua estrutura e observar as primeiras linhas:\n\nlibrary(readxl)\nriq &lt;- read_excel(\"dados_R.xlsx\", sheet = \"riqueza\")\n\nstr(riq)\n\ntibble [50 × 3] (S3: tbl_df/tbl/data.frame)\n $ riqueza     : num [1:50] 1 3 0 20 0 10 1 0 0 1 ...\n $ biomassa    : num [1:50] 0.722 1.835 -0.256 1.847 -1.9 ...\n $ luminosidade: num [1:50] 0.287 1.35 -0.683 -0.581 -0.472 ...\n\nhead(riq)\n\n# A tibble: 6 × 3\n  riqueza biomassa luminosidade\n    &lt;dbl&gt;    &lt;dbl&gt;        &lt;dbl&gt;\n1       1    0.722        0.287\n2       3    1.84         1.35 \n3       0   -0.256       -0.683\n4      20    1.85        -0.581\n5       0   -1.9         -0.472\n6      10    0.727       -0.812\n\n\nVamos criar um gráfico para avaliar a relação entre a variável resposta e as variáveis preditoras (Figura 10.1).\n\nlibrary(ggplot2)\n\nggplot(riq)+\n  geom_point(aes(x = biomassa, y = riqueza))\n\nggplot(riq)+\n  geom_point(aes(x = luminosidade, y = riqueza))\n\n\n\n\n\n\n\n\n\n\n(a) preditor: biomassa de serrapilheira\n\n\n\n\n\n\n\n\n\n\n\n(b) preditor: luminosidade (abertura do dossel)\n\n\n\n\n\n\nFigura 10.1: gráfico de dispersão relacionando a riqueza de espécies com biomassa e luminosidade.\n\n\n\n\nNos gráficos conseguimos ver que há uma relação positiva entre o número de espécies com o aumento da biomassa, entretanto parece que há uma relacão negativa entre a riqueza e a luminosidade.\nComo temos um dado de contagem, vamos criar um modelo linear generalizado:\n\nmodelo1 &lt;- glm(riqueza ~ biomassa * luminosidade, data = riq, family = poisson)\nsummary(modelo1)\n\n\nCall:\nglm(formula = riqueza ~ biomassa * luminosidade, family = poisson, \n    data = riq)\n\nCoefficients:\n                      Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)            0.39721    0.14218   2.794  0.00521 ** \nbiomassa               1.17932    0.11253  10.480  &lt; 2e-16 ***\nluminosidade          -0.95762    0.09501 -10.079  &lt; 2e-16 ***\nbiomassa:luminosidade  0.01153    0.07332   0.157  0.87503    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 499.017  on 49  degrees of freedom\nResidual deviance:  44.719  on 46  degrees of freedom\nAIC: 157.08\n\nNumber of Fisher Scoring iterations: 5\n\n\nO modelo indica que há relação positiva entre a riqueza e a biomassa da serrapilheira, entretanto temos uma relação negativa entre a luminosidade que atinge o sub-bosque devido à abertura do dossel e a riqueza de espécies. A interação antre as duas variáveis preditoras não foi significativa. Algumas particularidades sobre o resumo dos modelos lineares generalizados:\n\nEm vez de apresentar estatísticas sobre os resíduos, são apresentadas estatísticas descritivas do desvio (deviance).\nÉ preciso atenção com os coeficientes dos modelos, pois eles estão apresentados na escala do preditor linear. No caso dos modelos da família Poisson, a função de ligação canônica é a logarítmica. Para se colocar os coeficientes na escala da variável resposta, deve-se utilizar a função inversa, que no caso é a exponencial.\n\n\n10.2.1 Superdispersão (overdispersion)\nOutra coisa importante que deve ser levada em conta é que modelos como os da família Poisson e binomial assumem que o parâmetro de dispersão é igual a 1, o que pode não ser adequado. Caso este parâmetro não seja adequado, observaremos que o desvio residual (residual deviance) dividido pelos seus graus de liberdade será muito diferente de 1. No nosso exemplo, o desvio residual foi 44,7 para 46 graus de liberdade e, sendo assim, foi adequado. Caso haja discrepância entre o desvio residual e os graus de liberdade, pode ser interessante utilizar modelos de famílias que podem variar o parâmetro de dispersão. nesse caso pode ser utilizada a família quasi-poisson (com o argumento family = quasipoisson) ou binomial negativa (utilizando a função glm.nb() do pacote MASS). Para modelos da família binomial (apresentada a seguir), pode ser utilizada a família quasi-binomial (com o argumento family = quasibinomial). Mais detalhes sobre o assunto podem ser vistos em Jones et al. (2022).\n\n\n10.2.2 Simplificando o modelo\nPodemos criar um modelo mais simples sem interação e observar se esse modelo é melhor que o testado anteriormente. Para isso, podemos utilizar a função ANOVA para comparar os modelos como feito anteriormente. No caso de modelos lineares generalizados, a comparação deve ser feita por qui-quadrado, assim devemos incluir o argumento test=\"Chi\".\n\nmodelo2 &lt;- glm(riqueza ~ biomassa + luminosidade, data = riq, poisson)\n\nanova(modelo1, modelo2, test=\"Chi\")\n\nAnalysis of Deviance Table\n\nModel 1: riqueza ~ biomassa * luminosidade\nModel 2: riqueza ~ biomassa + luminosidade\n  Resid. Df Resid. Dev Df  Deviance Pr(&gt;Chi)\n1        46     44.719                      \n2        47     44.744 -1 -0.024573   0.8754\n\n\nPodemos observar que o modelo 1 não apresenta vantagem em relação ao modelo 2. Assim optamos por manter o modelo mais simples, que não inclui interação.\nVamos criar um gráfico com a curva da predição da riqueza pela biomassa e luminosidade.Para isso, utilizaremos o pacote ggeffects (Figura 10.2).\n\nlibrary(ggeffects)\n#biomassa\nriq.pred1 &lt;- ggpredict(modelo1, terms = c(\"biomassa\"))\nplot(riq.pred1, rawdata = TRUE)\n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n#luminosidade\nriq.pred2 &lt;- ggpredict(modelo1, terms = c(\"luminosidade\"))\nplot(riq.pred2, rawdata = TRUE)\n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n\n\n\n\n\n\n\n\n\n\n(a) preditor: biomassa de serrapilheira\n\n\n\n\n\n\n\n\n\n\n\n(b) preditor: luminosidade (abertura do dossel)\n\n\n\n\n\n\nFigura 10.2: gráficos de dispersão relacionando a riqueza de espécies, biomassa e luminosidade, incluindo ajuste do modelo linear generalizado.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos lineares generalizados (GLMs)</span>"
    ]
  },
  {
    "objectID": "c10_GLMs.html#dados-binários",
    "href": "c10_GLMs.html#dados-binários",
    "title": "10  Modelos lineares generalizados (GLMs)",
    "section": "10.3 Dados binários",
    "text": "10.3 Dados binários\nPodemos utilizar modelos lineares generalizados para analisar dados onde a variável resposta é binária.\nNo exemplo abaixo utilizaremos os dados da planilha pres_aus, que apresenta dados de presença/ausência de uma determinada espécie em fragmentos florestais, como uma função da área do fragmento e de sua distância de uma reserva florestal maior. No conjunto de dados, a variável presença está codificada como 0 e 1, onde 0 indica ausência e 1 indica presença da espécie:\n\npraus &lt;- read_excel(\"dados_R.xlsx\", sheet = \"pres_aus\")\nstr(praus)\n\ntibble [30 × 3] (S3: tbl_df/tbl/data.frame)\n $ presença : num [1:30] 1 1 0 1 0 1 1 1 0 0 ...\n $ area     : num [1:30] 10.5 13 8.3 13.1 4.6 10.5 6.4 7.4 5.4 8.9 ...\n $ distancia: num [1:30] 12.3 8.1 14.3 8.1 10.7 10.8 11.3 5.5 10.5 16.2 ...\n\nhead(praus)\n\n# A tibble: 6 × 3\n  presença  area distancia\n     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1        1  10.5      12.3\n2        1  13         8.1\n3        0   8.3      14.3\n4        1  13.1       8.1\n5        0   4.6      10.7\n6        1  10.5      10.8\n\n\nVamos criar dois modelos: um deles avaliando a interação entre as variáveis explanatórias e o outro não avaliando a interação.\n\npraus.modelo1 &lt;- glm(presença ~ area * distancia, data = praus, family = binomial) #com interação\npraus.modelo2 &lt;- glm(presença ~ area + distancia, data = praus, family = binomial) #sem interação\n\nVamos comparar os modelos:\n\nanova(praus.modelo1, praus.modelo2)\n\nAnalysis of Deviance Table\n\nModel 1: presença ~ area * distancia\nModel 2: presença ~ area + distancia\n  Resid. Df Resid. Dev Df  Deviance Pr(&gt;Chi)\n1        26     19.674                      \n2        27     19.688 -1 -0.014146   0.9053\n\n\nO modelo mais complexo (incluindo a interação) não é significativamente melhor, desta forma utilizamos o modelo mais simples pelo critério da parcimônia.\n\nsummary(praus.modelo2)\n\n\nCall:\nglm(formula = presença ~ area + distancia, family = binomial, \n    data = praus)\n\nCoefficients:\n            Estimate Std. Error z value Pr(&gt;|z|)   \n(Intercept)  -3.0103     3.2778  -0.918   0.3584   \narea          0.9672     0.3446   2.807   0.0050 **\ndistancia    -0.5204     0.2729  -1.907   0.0565 . \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 41.455  on 29  degrees of freedom\nResidual deviance: 19.688  on 27  degrees of freedom\nAIC: 25.688\n\nNumber of Fisher Scoring iterations: 6\n\n\nAo analisar as estimativas (Estimate) vemos uma relação positiva entre a presença de aves com area, e coeficiente de distância foi negativo. Assim fragmentos maiores tem mais chance de apresentar a espécie, enquanto fragmentos mais afastadas da reserva florestal têm uma probabilidade menor de apresentar a espécie. pelo teste-z, a distância foi marginalmente significativa, entretanto para avaliar de forma mais adequada, devemos realizar uma análise do desvio com a função anova():\n\nanova(praus.modelo2)\n\nAnalysis of Deviance Table\n\nModel: binomial, link: logit\n\nResponse: presença\n\nTerms added sequentially (first to last)\n\n          Df Deviance Resid. Df Resid. Dev  Pr(&gt;Chi)    \nNULL                         29     41.455              \narea       1  16.1616        28     25.294 5.816e-05 ***\ndistancia  1   5.6062        27     19.688    0.0179 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nNesta análise, a partir de um modelo nulo (presença ~ 1), as variáveis preditoras são adicionadas sequencialmente. Desta forma, vemos que tanto a adição da variável area como distância melhoram significativamente o modelo, desta forma devem ser mantidas. É preciso ter atencção em relação à interpretação dos valores do deviance, pois, como eles são adicionadoss equencialemnte, dependendo da ordem que forem adicionados, os valores serão diferentes.\nPodemos realizar a predição dos valores e preparar gráficos representando o modelo utilizando opacote ggeffects (Figura 10.3):\n#Gráfico para isolamento\npraus.pred.dist &lt;- ggpredict(praus.modelo2, terms =  c(\"distancia [all]\"))\nplot(praus.pred.dist, rawdata = TRUE)\n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n#Gráfico para incidência\npraus.pred.ar &lt;- ggpredict(praus.modelo2, terms =  c(\"area [all]\"))\nplot(praus.pred.ar, rawdata = TRUE)\n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) preditor: distância\n\n\n\n\n\n\n\n\n\n\n\n(b) preditor: área\n\n\n\n\n\n\n\nFigura 10.3: gráfico relacionando a probabilidade de se encontrar determinada espécie com as variáveis contínuas preditoras\n\n\n\n\n\n\n\nJones, E., Harden, S., & Crawley, M. J. (2022). The R book (Third edition). Wiley.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Modelos lineares generalizados (GLMs)</span>"
    ]
  },
  {
    "objectID": "c01_Instal.html",
    "href": "c01_Instal.html",
    "title": "1  Instalando o R",
    "section": "",
    "text": "1.1 Introdução\nNeste tópico, iremos aprender a instalar o R em seu computador. Em geral é indicado que se utilize uma interface para facilitar a utilização da linguagem R, como o RStudio, o VS Code ou diversos outros editores de texto voltados para a programação.\nNeste livro, utilizaremos o RStudio, que é um ambiente integrado de desenvolvimento (AID ou do inglês integrated development environment - IDE) que apresenta várias opções e recursos para visualização, marcação de sintaxe e preenchimento automático do script.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "c01_Instal.html#instalando-o-r-básico-base-r",
    "href": "c01_Instal.html#instalando-o-r-básico-base-r",
    "title": "1  Instalando o R",
    "section": "1.2 Instalando o R básico (Base-R)",
    "text": "1.2 Instalando o R básico (Base-R)\nO R é disponibilizado no site www.r-project.org. Ele pode ser instalado em computadores com os sistemas operacionais Windows, Linux ou Mac OSX. Abaixo estão descritos os passos para realizar a instalação (Figura 1.1, Figura 1.2, Figura 1.3).\n\nAcessar o site www.r-project.org;\nEntre em CRAN no menu lateral ;\nEscolha um espelho (“mirror”), dando preferência aos mais próximos, para realizar o download;\nEscolha a versão correspondente ao seu sistema operacional;\nEscolha a versão base ;\nFaça download da versão mais atual do R disponível;\nAbra o instalador R-x.x.x-win.exe (x.x.x representa o número da versão do R), clicando duas vezes nele.\nSiga as opções padrão de instalação do R;\nExecute o R a partir do menu iniciar. Dependendo do seu sistema operacional você deverá executar a versão de 32 bit ou 64 bit (x32 ou x64);\nAo final do processo você poderá visualizar a interface do R.\n\n\n\n\n\n\n\nFigura 1.1: Instalação do R\n\n\n\n\n\n\n\n\n\nFigura 1.2: Instalação do R (cont.)\n\n\n\n\n\n\nInstalação do R (cont.)\n\n\n\n\n\nInstalação do R (cont.)\n\n\n\n\n\nInstalação do R (cont.)\n\n\n\n\n\nInstalação do R (cont.)\n\n\n\n\n\n\n\n\nFigura 1.3: A interface do R\n\n\n\n\n\n\nA interface do R\n\n\n\n\n\nA interface do R",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "c01_Instal.html#instalando-o-rstudio",
    "href": "c01_Instal.html#instalando-o-rstudio",
    "title": "1  Instalando o R",
    "section": "1.3 Instalando o Rstudio",
    "text": "1.3 Instalando o Rstudio\nPara instalar o RStudio, siga os seguintes passos (Figura 1.4). Atenção: o R-base precisa estar instalado para executar o RStudio!\n\nEntre no website posit.co/download/rstudio-desktop/;\nClique em Install RStudio;\nSigas as instruções para instalação. Caso necessário, na mesma página abaixo, há outras versões do RStudio para serem baixadas.\n\n\n\n\n\n\n\nFigura 1.4: Instalando o Rstudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "c01_Instal.html#o-posit-cloud",
    "href": "c01_Instal.html#o-posit-cloud",
    "title": "1  Instalando o R",
    "section": "1.4 O Posit Cloud",
    "text": "1.4 O Posit Cloud\nO Posit Cloud permite acessar a interface RStudio de um navegador. Para cessar o Posit Cloud (Figura 1.5):\n\nAcesse https://posit.cloud;\nClique em “Get Started”;\nEscolha o plano mais adequado (pode ser o gartuito);\nClique em Sign up;\nCrie uma conta, podendo ser utilizada a conta Google.\n\n\n\n\n\n\n\nFigura 1.5: Acessando o Posit Cloud",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html",
    "href": "c02_IntroR.html",
    "title": "2  Introdução ao R",
    "section": "",
    "text": "2.1 A Interface do RStudio\nNo Rstudio podemos visualizar 4 janelas (Figura 2.1), sendo elas:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#a-interface-do-rstudio",
    "href": "c02_IntroR.html#a-interface-do-rstudio",
    "title": "2  Introdução ao R",
    "section": "",
    "text": "Editor: é onde digitamos os códigos. Nele temos um arquivo de texto que chamamos script. Se ela não aparecer, crie um novo script clicando no botão de atalho do canto superior esquerdo como apresentado no exemplo mais adiante.\nConsole: é a linha de comandos do R. Os comandos executados aparecem depois do símbolo “&gt;”, e os resultados também aparecem no console.\nAmbiente e história: onde ficam os objetos criados. “História”apresenta linhas de código recentemente utilizadas.\nOutput: Apresenta outras informações, como gráficos gerados, arquivos de ajuda, etc.\n\n\n\n\n\n\n\nFigura 2.1: Visão geral do RStudio",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#criando-um-script",
    "href": "c02_IntroR.html#criando-um-script",
    "title": "2  Introdução ao R",
    "section": "2.2 Criando um script",
    "text": "2.2 Criando um script\nUma das melhores formas de registrar as análises realizadas para posteriormente executá-las novamente no R é salvando um script com todas as informações e incluindo os comentários após o “#” de forma a organizar e lembrar o que foi feito. O script pode ser salvo com a extensão .R. Abaixo temos um exemplo de script, utilizando o “#”, e também os símbolos de “=” e “-” de forma a delimitar blocos. Observe que tudo que está após os “#” fica realçado da mesma cor pela marcação de sintaxe (Figura 2.2).\n\n\n\n\n\n\nFigura 2.2: Criando um novo script. O caminho para a criação do script está enfatizado em vermelho\n\n\n\nAbaixo temos um exemplo de texto script:\n\n#==================================================#\n# Introdução ao R\n# data: 15 de setembro de 2023\n#==================================================#\n\n#Sintaxe e operações aritméticas ####\n\n#soma - utilizar o operador aritmético \"+\"\n1+2\n\n#subtração - utilizar o operador aritmético \"-\"\n10 - 5 \n\nObs.: no Rstudio, após o título de um tópico iniciado com hashtag, você pode usar 4 hashtags seguidos (####) para indicar um tópico principal; também pode utilizar ==== para indicar um tópico secundário e ---- para indicar um tópico terciário.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#sintaxe-e-operações-aritméticas",
    "href": "c02_IntroR.html#sintaxe-e-operações-aritméticas",
    "title": "2  Introdução ao R",
    "section": "2.3 Sintaxe e operações aritméticas",
    "text": "2.3 Sintaxe e operações aritméticas\nO R pode ser utilizado para realizar cálculos simples. Para executar um comando no R, faça alguma das duas ações:\n\nDigite 1 + 2 no editor e pressione Ctrl+ENTER. Assim a informação passada no editor será executada no script\nDigite 1 + 2 diretamente no console e pressione ENTER\n\n\n1 + 2\n\n[1] 3\n\n\nO resultado da digitação aparece como na Figura 2.3 .\n\n\n\n\n\n\nFigura 2.3: Resultado da soma apresentado no console\n\n\n\nComo resposta, teremos o resultado da operação.\n\n2.3.1 Exemplos de operações aritméticas no R\nVocê pode realizar as seguintes operações matemáticas e a descrição delas no editor. Depois disso, execute-as, deixando a barra de digitação na linha a ser executada e clicando CTRL + ENTER. Você também pode selecionar todo o trecho a ser executado e executar com CTRL + ENTER:\n\n10 + 5 #soma\n10 - 5 #subtração\n10 * 5 #multipicação\n10 / 5 #divisão\n11 %/% 5 #divisão de inteiros\n11 %% 5 #divisão modular\n\nAo executar o código acima, o resultado será exibido no console Figura 2.4\n\n\n\n\n\n\nFigura 2.4: Resultado das operações aritméticas digitadas no editor. Após executá-las clicando CTRL + ENTER, os resultados aparecerão no console.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#atribuição-criando-objetos",
    "href": "c02_IntroR.html#atribuição-criando-objetos",
    "title": "2  Introdução ao R",
    "section": "2.4 Atribuição: criando objetos",
    "text": "2.4 Atribuição: criando objetos\nAo executar o comando executado acima, obtemos o resultado da operação. No entanto esse resultado não é salvo em nenhum local. Na linguagem R, para que nosso resultado fique salvo para uma próxima etapa, devemos criar um objeto.\nO R é uma linguagem orientada a objetos. As planilhas, resultados de análise, funções utilizadas para realizar as análises, etc, são salvos como objetos. Para criar objetos, utilizamos o operador de atribuição (&lt;-). Assim, podemos criar um objeto no R que irá salvar o resultado no R:\n\na &lt;- 1 + 2\n\nObserve que, diferentemente do passo anterior, não obtivemos um resultado no prompt. Entretanto podemos observar o resultado chamando pelo objeto a que criamos. Para isso, simplesmente escrevemos o nome do objeto (a) no script e clicamos CTRL+ENTER:\n\na\n\n[1] 3\n\n\nPodemos utilizar os símbolos de atribuição como o sinal de menor seguido de hífen, formando uma seta (&lt;-), mas isto em geral também pode ser feito utilizando o sinal de igualdade (=). Após digitar o valor, você poderá utilizar o símbolo de atribuição ao contrário. A função assign() pode ser utilizada para atribuição (obs: funções são explicadas em um tópico posterior). Todos os comandos abaixo funcionam da mesma forma: atribuem o valor de 1 + 2 ao objeto a:\n\na &lt;- 1 + 2\na = 1 + 2\n1 + 2 -&gt; a\nassign(\"a\", 1 + 2)\n\nNomes de objetos Podemos colocar o nome que quisermos em um objeto. No exemplo abaixo criamos um objeto de texto (caracteres) Meu.objeto. Para inserir texto, colocamos este entre aspas (\"\"). Observe que ao chamar o objeto, tivemos erro no primeiro caso. isso se deve ao fato de utilizarmos letra maiúscula no nome do objeto. Assim, vemos que a linguagem R e sensível a diferenças entre maiúsculas e minúsculas.\n\nMeu.objeto &lt;- \"Aprender R é fácil\"\nmeu.objeto #retorna uma mensagem de erro, \n            #pois escrevemos o nome do objeto em minúsculo.\nMeu.objeto #retorna o resultado esperado - imprime o texto\n\nObserve que todos os objetos criados aparecem na tela superior á esquerda, na aba Environment.\nAtenção: Alguns nomes de objeto não são aceitos, por exemplo:\n\nO nome de um objeto não pode começar por um número;\nO nome de um objeto não pode ser separado por hífen (-);\nNão pode haver espaço no nome do objeto\n\n\n1meuobjeto #não funciona; nome não pode começar por número\nmeu-objeto #não funciona\nmeu objeto #erro -não pode haver espaço no nome\nmeu.objeto1 #funciona, nome apresenta número mas só no final.\n\nEssas limitações podem ser contornadas caso se inclua o nome do objeto entre o sinal ``.\n\n`1Meu objeto-` &lt;- \"Aprender R é fácil\"\n`1Meu objeto-` #funcionou",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#funções",
    "href": "c02_IntroR.html#funções",
    "title": "2  Introdução ao R",
    "section": "2.5 Funções",
    "text": "2.5 Funções\nUm tipo de objeto que temos no R são as funções. Funções são blocos de código que executam uma tarefa específica e podem ser reutilizados em diferentes partes do seu programa. Elas ajudam a organizar o código, tornando-o mais eficiente e fácil de entender. Funções podem receber entradas (argumentos ou parâmetros) e retornar um valor como resultado. Por exemplo podemos usar a função log para calcular o logaritmo de um determinado valor:\n\nlog(3)\n\n[1] 1.098612\n\nlog(a) #calcula o logaritmo do objeto a\n\n[1] 1.098612\n\n\nAssim calculamos o logaritmo de 3. Entretanto, como sabemos qual é a base do logaritmo? Veremos isso a seguir.\n\n2.5.1 Ajuda de funções\nO R apresenta uma documentação abrangente, e para cada função e pacote há uma descrição do seu funcionamento. Essa documentação é importante e permite uma compreensão mais abrangente de como cada função pode ser utilizada. Para entender melhor uma função, podemos realizar pesquisas na ajuda. Isso pode ser realizado de diferentes formas:\n\nhelp(log)\n?log\n\nAo observar a ajuda da função log, no tópico “Usage” observamos que podemos utilizar a função log com a seguinte sintaxe:\nlog(x, base = exp(1))\nAssim, se quisermos calcular o logaritmo de 10 na base 10, poderíamos fazer isso de qualquer uma das formas a seguir:\n\nlog(10, base = 10)\nlog(10, 10)\nlog(base = 10, 10)\n\n\n\n2.5.2 Funções e argumentos\nPodemos ver que a função log trabalha com 2 argumentos, que são o valor (x) e a base do logaritmo. Com isso, podemos ver que as funções apresentam a seguinte sintaxe:\nfunção(argumento1 = valor, argumento2 = valor , …)\nVocês puderam observar no exemplo que em geral podemos omitir o nome do argumento caso mantenhamos a posição dos argumentos dentro da função.\nVocê pode realizar diversas operações com objetos, como mostrado abaixo:\n\na &lt;- 10\nlog(a, base=10)\nb &lt;- 2\nlog(a, base=10)*b\n(a*b-&gt;c)\n\nObs: O objeto a anteriormente tinha o valor 3. Criamos um novo objeto a com valor 10. Desta forma, o valor de a foi alterado.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#pacotes",
    "href": "c02_IntroR.html#pacotes",
    "title": "2  Introdução ao R",
    "section": "2.6 Pacotes",
    "text": "2.6 Pacotes\nExistem vários pacotes que apresentam funções específicas para determinadas finalidades. No exemplo, vamos instalar o pacote ggplot2, que oferece ferramentas avançadas para a elaboração de gráficos. Abaixo iremos:\n\nFazer download e instalar o pacote ggplot2.\nAbrir o pacote, de forma que suas funções fiquem disponíveis. Isso deve ser feito sempre que pretendemos utilizar o pacote.\nObservar a ajuda sobre o pacote.\n\n\ninstall.packages(\"ggplot2\") # instalar pacote de interesse\nlibrary(ggplot2) # carregar o pacote para ser utilizado\n?ggplot2 # ajuda do pacote",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#algumas-funções",
    "href": "c02_IntroR.html#algumas-funções",
    "title": "2  Introdução ao R",
    "section": "2.7 Algumas funções",
    "text": "2.7 Algumas funções\n\n2.7.1 Como citar o R em artigos?\nPara verificar como citar o R ou algum pacote em um artigo, pode ser usada a função citation():\n\ncitation() #como citar o R\ncitation(\"ggplot2\") #como citar o pacote ggplot2\n\n\n\n2.7.2 Listar objetos\nVocê pode listar todos os objetos disponíveis em seu ambiente de trabalho com a função ls():\n\nls()\n\n[1] \"a\"\n\n\n\n\n2.7.3 Remover objetos\nUm objeto pode ser removido utilizando a função rm():\n\nrm(Meu.objeto)\nrm(list = ls()) # remove todos os objetos criados.\nls() #character(0) - isso quer dizer que não há mais nenhum objeto",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#estruturas-de-dados",
    "href": "c02_IntroR.html#estruturas-de-dados",
    "title": "2  Introdução ao R",
    "section": "2.8 Estruturas de dados",
    "text": "2.8 Estruturas de dados\nEstruturas de dados são formas de armazenar e organizar dados para que possam ser utilizados em cálculos. Alguns tipos de estruturas de dados muito utilizados são:\n\nVetores: uma sequência de valores numéricos ou de caracteres (letras, palavras).\nMatrizes: coleção de vetores em linhas e colunas.\nData frame: planilha de dados.\nListas: conjunto de vetores, dataframes ou de matrizes. Versátil.\n\n\n2.8.1 Vetores\nSão objetos nos quais podemos guardar vários valores. Criamos vetores utilizando a função de concatenação: c(). Vetores numéricos são as estruturas de dados mais simples do R. Vamos preparar vetores com dados de roedores, retirados de de “The Portal Project Teaching Database” (Ernest et al., 2020).\nVamos criar um vetor chamado peso, com 10 valores. Após criarr o vetor com a função c(), podemos executar o comando peso, para ver os 10 valores que digitamos:\n\npeso &lt;- c(9,7,42,44,49,49,154,166,31,32) # peso em gramas\npeso\n\n [1]   9   7  42  44  49  49 154 166  31  32\n\n\nOs pesos correspondem a machos e fêmeas de 5 espécies de roedores. Vamos criar vetores com outras informações dos roedores:\n\ncomprimento, com os comprimentos dos pés posteriores dos roedores em mm.\nsexo, com o sexo deles.\nespecie, com a espécie a qual eles pertencem: Baiomys taylori (BA), Dipodomys merriami (DM), Dipodomys ordii (DO), Neotoma albigula (NL) e Onychomys leucogaster (OL).\n\n\n#comprimento\ncomprimento &lt;- c(13,13,36,36,35,36,32,33,20,21)\n\n#nomes\nespecie &lt;- c(\"BA\",\"BA\",\"DM\",\"DM\",\"DO\",\"DO\",\"NL\",\"NL\",\"OL\",\"OL\")\n\n#sexo\nsexo &lt;- c(\"F\",\"M\",\"F\",\"M\",\"F\",\"M\",\"F\",\"M\",\"F\",\"M\")\n\n\n\n2.8.2 Matrizes\nMatrizes são interessantes na matemática e estatística. Vamos criar uma matriza com valores de 1 a 9 para observar como as funções para matrizes funcionam no R:\n\n?matrix # ajuda da função matrix\n\n# criando uma matriz\nmatrix(c(1,2,3,4,5,6,7,8,9),nrow = 3) # matriz com 3 linhas e valores de de 1 a 9.\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nmatrix(1:9,nrow = 3) #outra forma\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nmatrix(c(1,2,3,4,5,6,7,8,9),nrow = 5) # A matriz tem mais elementos \n\nWarning in matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 5): data length [9] is\nnot a sub-multiple or multiple of the number of rows [5]\n\n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5    1\n\n#do que 1 a 9. ela volta a preencher o elemento final com o primeiro elemento.\n\nAbaixo, iremos\n\nCriair uma matriz A;\nObservar a diagonal da matriz com a função diag();\nObservar o número de linhas e colunas da matriz com dim().\nTranspor a matriz com t().\n\n\nA &lt;- matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\ndiag(A) #diagonal da matriz\n\n[1] 1 5 9\n\ndim(A) #uma matriz 3X3\n\n[1] 3 3\n\nt(A) # matriz transposta\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nVamos utilizar um exemplo prático em ecologia de populações. Utilizaremos uma matriz de Leslie para calcular tamanhos populacionais em diferentes categorias de tamanho após um tempo (Gotelli, 2007). A Matriz de Leslie apresenta uma coluna para cada classe etária. Na primeira linha temos as fecundidades para cada classe etária. A subdiagonal da matriz de Leslie apresenta a probabilidade se sobrevivência até a próxima classe. Abaixo temos um exemplo para uma população com 4 classes etárias. A matriz foi dividida em linhas abaixo para facilitar a visualização:\n\nL &lt;- matrix(c(0  , 4  , 3 , 0,\n              0.5, 0  , 0 , 0,\n              0  ,0.3 , 0 , 0,\n              0  , 0  ,0.2, 0), ncol = 4, byrow = TRUE)\n#sem dividir em linhas:\nL &lt;- matrix(c(0 , 4, 3, 0, 0.5, 0, 0, 0, 0, 0.3, 0, 0, 0, 0, 0.2, 0), ncol = 4, byrow = TRUE)\nL\n\n     [,1] [,2] [,3] [,4]\n[1,]  0.0  4.0  3.0    0\n[2,]  0.5  0.0  0.0    0\n[3,]  0.0  0.3  0.0    0\n[4,]  0.0  0.0  0.2    0\n\n\nPodemos criar uma matriz coluna com os dados do tamanho populacional para cada faixa etária em um determinado tempo:\n\npop &lt;- matrix(c(100, 60, 20, 5), ncol = 1)\npop\n\n     [,1]\n[1,]  100\n[2,]   60\n[3,]   20\n[4,]    5\n\n\nA partir da matriz coluna com o tamanho da população em cada faixa etária, podemos calcular o número de indivíduos em cada classe etária no tempo t+1. A multiplicação tem algumas particularidades, e ela é realizada no R utilizando ooperador %*%.\n\nL %*% pop\n\n     [,1]\n[1,]  300\n[2,]   50\n[3,]   18\n[4,]    4\n\nsum(pop)#tamanho da população em t\n\n[1] 185\n\nsum(L %*% pop)#tamanho da população em t+1\n\n[1] 372\n\n\n\n\n2.8.3 Conjuntos de dados (data frame)\nEm geral, quando vamos organizar os dados em uma planilha, utilizamos estruturas muito parecidas com o formato data frame. Neste tipo de objeto temos colunas representando variáveis e linhas representando observações.Vamos utilizar a função data.frame() para criar uma planilha com os dados de roedores:\n\nroedores &lt;- data.frame(especie, sexo, peso, comprimento)\nroedores\n\n   especie sexo peso comprimento\n1       BA    F    9          13\n2       BA    M    7          13\n3       DM    F   42          36\n4       DM    M   44          36\n5       DO    F   49          35\n6       DO    M   49          36\n7       NL    F  154          32\n8       NL    M  166          33\n9       OL    F   31          20\n10      OL    M   32          21\n\n\nQuais as dimensões do objeto?\n\ndim(roedores) \n\n[1] 10  4\n\n\nTemos 10 linhas (observações) e 4 colunas, que correspondem às variáveis observadas (espécie, sexo, peso, comprimento)\n\n\n2.8.4 Listas\nAs listas são objetos versáteis, que podem conter diversos tipos de informações concatenadas.\n\nminha.lista &lt;- list(\"roedores\"= roedores,\"matriz\" = L,\"número\"=3)\nminha.lista\n\n$roedores\n   especie sexo peso comprimento\n1       BA    F    9          13\n2       BA    M    7          13\n3       DM    F   42          36\n4       DM    M   44          36\n5       DO    F   49          35\n6       DO    M   49          36\n7       NL    F  154          32\n8       NL    M  166          33\n9       OL    F   31          20\n10      OL    M   32          21\n\n$matriz\n     [,1] [,2] [,3] [,4]\n[1,]  0.0  4.0  3.0    0\n[2,]  0.5  0.0  0.0    0\n[3,]  0.0  0.3  0.0    0\n[4,]  0.0  0.0  0.2    0\n\n$número\n[1] 3\n\n\nNesta lista, salvamos nossos dados deroedores, a matriz que criamos anteriormente, e um número em uma lista.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#classes-de-objetos",
    "href": "c02_IntroR.html#classes-de-objetos",
    "title": "2  Introdução ao R",
    "section": "2.9 Classes de objetos",
    "text": "2.9 Classes de objetos\nA função class() pode ser usada para descobrirmos o tipo de objeto.\n\nclass(comprimento) #vetor numérico\n\n[1] \"numeric\"\n\nclass(sexo) #vetor de caracteres (vetor de texto)\n\n[1] \"character\"\n\n\nPodemos transformar um objeto de caracter em um fator:\n\nsexo &lt;- factor(sexo)\nsexo  \n\n [1] F M F M F M F M F M\nLevels: F M\n\n  #levels: representam os estados do fator\nclass(sexo)\n\n[1] \"factor\"\n\n\nQual a diferença entre um objeto do tipo “character” e um objeto do tipo”factor”? Fatores são uma estrutura de dados usada para armazenar variáveis categóricas, ou seja, variáveis que representam categorias ou grupos de dados, como “sexo” (masculino e feminino) ou “cor” (vermelho, azul, verde). Eles são utilizados principalmente quando os dados possuem valores repetidos que podem ser agrupados em diferentes níveis (levels).\nAo invés de tratar essas variáveis como texto simples (strings), o R converte os valores em números que referenciam essas categorias. Em geral, fatores ou variáveis de caracteres funcionam da mesma forma em R, mas os fatores costumam ocupar menos espaço em disco. Algumas análises e funções demandam que as variáveis do tipo “character” sejam transformadas em fatores.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#trabalhando-com-vetores",
    "href": "c02_IntroR.html#trabalhando-com-vetores",
    "title": "2  Introdução ao R",
    "section": "2.10 Trabalhando com vetores",
    "text": "2.10 Trabalhando com vetores\n\n2.10.1 Selecionar elementos de um vetor\nOs elementos de um vetor podem ser selecionados utilizando o número do elemento que queremos selecionar entre colchetes [ ] .\n\npeso[3] #selecionando o terceiro elemento\n\n[1] 42\n\npeso[3:4] #selecionando todos os elementos entre o terceiro e o quarto.\n\n[1] 42 44\n\npeso[c(1,3,5,7,9)] #seleciona os elementos 1,3,5,7 e 9\n\n[1]   9  42  49 154  31\n\n\n\n\n2.10.2 Algumas operações com vetores\nAlgumas funções importantes podem ser usadas para realizar operações matemáticas em um vetor:\n\nsum(): soma dos elementos do vetor.\nmean(): média dos elementos.\nlength(): número de elementos no vetor.\ntable(): cria uma tabela de contagem para vetores de caracter.\nmin(): menor valor presente no vetor.\nmax(): maior valor presente no vetor.\nrange(): menor e maior valores presentes no vetor\n\n\nsum(peso) #soma das alturas\n\n[1] 583\n\nmean(peso) #média das alturas\n\n[1] 58.3\n\nlength(peso) #número de elementos do objeto altura\n\n[1] 10\n\n#Tabela com quantos indivíduos de cada sexo no vetor\ntable(sexo) \n\nsexo\nF M \n5 5 \n\nmin(peso) # menor valor de altura\n\n[1] 7\n\nmax(peso) # maior valor de altura\n\n[1] 166\n\nrange(peso) # maior e menor valor de altura\n\n[1]   7 166\n\n\nPodemos também realizar operações matemáticas com vetores. No exemplo abaixo vamos:\n\nDividir o comprimento em mm por 10 para obter comprimento em cm;\nCalcular a razão entre peso e comprimento do pé (peso/comp. pé):\n\n\ncomprimento/10 #1\n\n [1] 1.3 1.3 3.6 3.6 3.5 3.6 3.2 3.3 2.0 2.1\n\npeso / comprimento #2 \n\n [1] 0.6923077 0.5384615 1.1666667 1.2222222 1.4000000 1.3611111 4.8125000\n [8] 5.0303030 1.5500000 1.5238095\n\n\n\n\n2.10.3 Utilizando operadores relacionais\nOperadores relacionais retoram uma resposta lógica (verdadeiro [TRUE] ou falso [FALSE]) e podem ser dos seguintes tipos:\n\n\n\nOperador\nDescrição\n\n\n\n\n==\nigualdade\n\n\n!=\ndiferença\n\n\n&gt;\nmaior\n\n\n&lt;\nmenor\n\n\n&gt;=\nMaior ou igual\n\n\n&lt;=\nMenor ou igual\n\n\n\n\n1 &gt; 1 #1 é maior que 1?\n\n[1] FALSE\n\n1 == 1 #1 é igual a 1? \n\n[1] TRUE\n\n\nOs argumentos lógicos podem ser utilizados em vetores para selecionar elementos em um vetor. Vamos:\n\nVerificar quais elementos do vetor peso são maiores que 100 gramas.\nVerificar quantos elementos do vetor têm peso maior que 100 gramas. Argumentos lógicos funcionam como números (TRUE = 1 e FALSE = 0), desta forma, podemos somá-los como no exemplo abaixo:\n\n\npeso &gt; 100 #1: quais elementos tem peso maior que 100 g (V ou F)?\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n\nsum(peso &gt; 100) #2: quantos elementos tem peso maior que 100 g?\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#trabalhando-com-data-frames",
    "href": "c02_IntroR.html#trabalhando-com-data-frames",
    "title": "2  Introdução ao R",
    "section": "2.11 Trabalhando com data frames",
    "text": "2.11 Trabalhando com data frames\n\n2.11.1 Selecionando linhas e colunas: indexação\nEm um data frame podemos selecionar as linhas e colunas dele utilizando a seguinte notação: nome_do_data_frame[linha, coluna]\nVeja o exemplo abaixo:\n\nroedores[1,] # selecionar a primeira linha do dataframe\nroedores[2,] # selecionar a segunda linha do dataframe\nroedores[,2] # selecionar a segunda coluna\n\nroedores[1,2] #selecionar elemento da 1a linha e 2a coluna\nroedores[,-4] #selecionar todas as colunas menos a 4a coluna\n\nroedores[-(1:5),] #todas as linhas menos as linhas 1 a 5\n\nPodemos também selecionar as colunas pelo nome, e realizar operações nelas como se fossem vetores:\n\nroedores$peso # selecionar coluna peso\n\n [1]   9   7  42  44  49  49 154 166  31  32\n\nroedores$especie # coluna especies\n\n [1] \"BA\" \"BA\" \"DM\" \"DM\" \"DO\" \"DO\" \"NL\" \"NL\" \"OL\" \"OL\"\n\n#operações com a s colunas do dataframe\nrange(roedores$peso) #valor minimo e máximo da coluna\n\n[1]   7 166\n\ntable(roedores$sexo) # tabela com contagem de elementos de cada sexo\n\n\nF M \n5 5 \n\n\n\n\n2.11.2 Classe e estrutura de um data frame:\nObserve o output das seguintes funções:\n\nclass(roedores) # é um objeto do tipo data.frame\n\n[1] \"data.frame\"\n\nstr(roedores) # estrutura do objeto: mostra o que é cada variável\n\n'data.frame':   10 obs. of  4 variables:\n $ especie    : chr  \"BA\" \"BA\" \"DM\" \"DM\" ...\n $ sexo       : chr  \"F\" \"M\" \"F\" \"M\" ...\n $ peso       : num  9 7 42 44 49 49 154 166 31 32\n $ comprimento: num  13 13 36 36 35 36 32 33 20 21\n\n\nO resultado (output) de str() mostra cada variável, sua classe e os valores:\n\n'data.frame': o objeto é um dataframe com 10 observações (obs: linhas) e 4 variáveis (variables: colunas).\n$ especie: a coluna especie é do tipo “caracter” (chr), e os primeiros elementos são “BA” “BA” “DM” “DM”.\n$ peso: a coluna peso é do tipo numérica (num), e os primeiros elementos são 9 7 42 44 49, etc.\n\n\n\n2.11.3 Filtrando linhas de um data frame\nPodemos usar operadores relacionais para selecionar linhas de interesse em um data frame. Vamos selecionar somente as linhas com personagens do sexo feminino:\n\nroedores$sexo #coluna com sexo dos personagens\n\n [1] \"F\" \"M\" \"F\" \"M\" \"F\" \"M\" \"F\" \"M\" \"F\" \"M\"\n\nroedores$sexo == \"F\" # Sexo feminino - verdadeiro ou falso?\n\n [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nroedores[roedores$sexo == \"F\",] #seleciona linhas em que sexo == \"F\"\n\n  especie sexo peso comprimento\n1      BA    F    9          13\n3      DM    F   42          36\n5      DO    F   49          35\n7      NL    F  154          32\n9      OL    F   31          20\n\n\nA seleção de colunas de interesse pode ser realizada usando a função subset(). Vamos fazer um subconjunto do conjunto de dados roedores que contenha somente os roedores do sexo feminino:\n\nsubset(roedores, sexo == \"F\") #selecionar pesrosagens do sexo feminino\n\n  especie sexo peso comprimento\n1      BA    F    9          13\n3      DM    F   42          36\n5      DO    F   49          35\n7      NL    F  154          32\n9      OL    F   31          20",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c02_IntroR.html#salvando-os-resultados",
    "href": "c02_IntroR.html#salvando-os-resultados",
    "title": "2  Introdução ao R",
    "section": "2.12 Salvando os resultados",
    "text": "2.12 Salvando os resultados\nUma das principais formas de salvar os resultados obtidos no R é salvando o script gerado no editor. Após criar um script, você pode salvá-lo clicando no ícone de salvar logo acima do editor (Figura 2.2). O Script é um arquivo de texto simples com a extensão .R. Ele pode ser aberto no R, e a partir dele, suas análises podem ser executadas novamente.\nCom o script, você pode executar novamente suas análises. Caso além disso, você também pode salvar seus objetos, você pode fazer isso com as funções save() para salvar alguns objetos em particular, ou save.image() para salvar todos os objetos criados na seção. No exemplo abaixo, salvamos os objetos stwars e StwarsPeso.RData com o nome stwarsPeso.RData. Depois salvamos todos os objetos criados com o nome objetos.RData:\n\n#salvar os objetos peso e altura\nsave(roedores, peso, file = \"roedoresPeso.RData\")\nsave.image(\"objetos.RData\")\n\n\n2.12.1 Onde os objetos foram salvos?\nO R trabalha em um determinado diretório de trabalho em seu computador. Seius arquivos serão primariamente lidos e salvos nesse diretório. Você pode descobrir qual é o diretório com a função getwd(). Se você quiser mudar este diretório, pode selecionar o diretório com a função setwd(), incluindo o caminho para o arquivo. Você também pode visualizar quais arquivos estão salvos no diretório com a função dir(). No RStudio, em vez de utilizar a função setwd(), o diretório pode ser configurado clicando pelo caminho: Session: Set Working Directory: Choose Directory. Veremos isso novamente no próximo capítulo.\n\ngetwd() # descobrir diretório\nsetwd(\"/Users/fernandohfarache/Documents/AnalisesR\") #definir diretório\ndir() #verificar arquivos salvos no diretório\n\n\n\n\n\nErnest, M., Brown, J., Valone, T., & White, E. P. (2020). Portal Project Teaching Database. https://doi.org/10.6084/M9.FIGSHARE.1314459.V10\n\n\nGotelli, N. J. (2007). Ecologia (3. ed). Ed. Planta.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "c03_Import.html",
    "href": "c03_Import.html",
    "title": "3  Conjuntos de dados e importação",
    "section": "",
    "text": "3.1 Organização de dados\nA forma de se organizar um conjunto de dados é muito importante, e pode facilitar muito a compreensão da forma como se irá analisar os dados dados. Existem muitas formas como os dados serão organizados e planilhados, o que pode mudar dependendo da área de pesquisa.\nEm um passo inicial, provavelmente os dados serão tabulados em papel ou utilizando uma planlha em um software como Excel, Planilhas do Google ou similar. A organização desses dados muitas vezes depende da área de pesquisa. Entretanto, na hora de se analisar os dados, é necessário aplicar algum sistema de organização que facilite a filtragem, reorganização (data wrangling), preparação de gráficos, estatísticas descritivas e inferência estatística. Podemos chamar esse tipo de conjunto de dados de dados organizados ou tidy data (Wickham et al., 2023).\nA organização ideal de um conjunto de dados segue alguns princípios (Wickham et al., 2023, Figura 3.1):\nUma variável é uma característica de interesse medida nas unidades amostrais. Exemplos: peso, altura, sexo, espécie. As variáveis podem ser numéricas quando podem ser medidas em escala quantitativa. As variáveis numéricas podem ser divididas em contínuas, quando podem assumir valores reais dentro de uma escala, ou discretas, quando só podem assumir números inteiros. Além disso, as variáveis podem ser categóricas (ou qualitativas) quando expressam uma classificação de observações em algum agrupamento (por exemplo, sexo ou espécie). As variáveis categóricas podem ser ordinais quando existe uma ordem entre as categorias (por exemplo, ensino fundamental, médio e superior).\nObserve os conjuntos de dados abaixo (Tabela 3.1):\nTabela 3.1: formas diferentes de se exibir um mesmo conjunto de dados\n\n\n\n\n\n\n(a) tabela a\n\n\n\n\n\nespecie\nsexo\npeso_medio\n\n\n\n\nAdelia\nFemea\n3368.836\n\n\nAdelia\nMacho\n4043.493\n\n\nBarbicha\nFemea\n3527.206\n\n\nBarbicha\nMacho\n3938.971\n\n\nGentoo\nFemea\n4679.741\n\n\nGentoo\nMacho\n5484.836\n\n\n\n\n\n\n\n\n\n\n\n(b) tabela b\n\n\n\n\n\nespecie\nFemea\nMacho\n\n\n\n\nAdelia\n3368.836\n4043.493\n\n\nBarbicha\n3527.206\n3938.971\n\n\nGentoo\n4679.741\n5484.836\nVocê pode observar que as duas tabelas exibem as mesmas informações. Entretanto, somente a tabela a apresenta está devidamente organizada como tidy data, apresentando somente uma variável por coluna e uma observação por linha.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos de dados e importação</span>"
    ]
  },
  {
    "objectID": "c03_Import.html#organização-de-dados",
    "href": "c03_Import.html#organização-de-dados",
    "title": "3  Conjuntos de dados e importação",
    "section": "",
    "text": "Cada variável é representada por uma coluna;\nCada observação é representada por uma linha e cada linha representa uma observação;\nCada valor está contido em uma única célula e cada célula contém somente um valor.\n\n\n\n\n\n\n\nFigura 3.1: Variáveis, observações e valores",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos de dados e importação</span>"
    ]
  },
  {
    "objectID": "c03_Import.html#importando-dados",
    "href": "c03_Import.html#importando-dados",
    "title": "3  Conjuntos de dados e importação",
    "section": "3.2 Importando dados",
    "text": "3.2 Importando dados\nO R é capaz de importar dados em diferentes formatos. Funções da família read.table() permitem importar diversos tipos de conjuntos de dados separados por tabulações ou separados por vírgula (.csv, com as funções read.csv() e read.csv2()). Existem pacotes que permitem a importação de tabelas do Excel, e de diversas outras formas. Neste tutorial, vamos importar os dados diretamente do excel utilizando o pacote readxl.\n\n3.2.1 Criando uma pasta de trabalho\nPrimeiramente, sempre que queremos começar uma nova análise, é interessante criar uma pasta de trabalho no computador, onde colocamos nossos conjuntos de dados, scripts, etc. No exemplo, foi criada uma pasta contendo somente o arquivo excel a ser importado e o script referente às análises Figura 3.2 .\n\n\n\n\n\n\nFigura 3.2: Organizando diretório para análises\n\n\n\n\n\n3.2.2 Definindo diretório de trabalho\nPodemos definir pasta de trabalho no RStudio no menu Session &gt; Set Working Directory &gt; Choose Directory… e escolher a pasta de trabalho desejada (Figura 3.3)\n\n\n\n\n\n\nFigura 3.3: Definindo diretório de trabalho\n\n\n\nO diretório de trabalho pode ser definido utilizando linhas de comando. Podemos usar a função setwd() para definir o diretório de trabalho:\n\nsetwd(\"/Users/fernandofarache/Documents/R_work/Aula02\") # escolher a pasta de trabalho\nsetwd(choose.dir()) #você pode usar choose.dir() para escolher o diretório clicando nele.\n\nAo escolher o diretório, podemos usar a função getwd() para descobrir se estamos mesmo no diretório certo. A função dir() permite descobrirmos se nossos arquivos estão mesmo lá.\n\ngetwd() # descobrir em qual pasta estamos\ndir()#observa os arquivos disponíveis na minha pasta\n\n\n\n3.2.3 Importando arquivos Excel\nO pacote readxl oferece funções para a leitura direta de arquivos Excel. Podemos importar a aba pinguins do arquivo Bioestat_PPGBio.xlsx. Atenção: o arquivo .xlsx deve estar no diretório de trabalho, ou o caminho para o diretório contendo a pasta deve ser indicado:\n\ninstall.packages(\"readxl\") #instalar parote readxl\n\n\nlibrary(readxl) # abrir o pacote para utilizá-lo\n\npinguins &lt;- read_excel(\"dados_R.xlsx\", sheet = \"pinguins\") #importar a aba \"pinguins\" do arquivo Bioestat_PPGBio.xlsx\n\n\n\n3.2.4 Importando arquivos fora do diretório de trabalho\nPodemos importar um arquivo a partir de qualquer diretório do computador, e nào somente do diretório de trabalho. Sendo assim, não é necessário ter definido um diretório de trabalho, como no exemplo abaixo:\n\npinguins &lt;- read_excel(\"/Users/fernandohfarache/Documents/DisciplinaR/dados_R.xlsx\", sheet = \"pinguins\")\n\n\n\n3.2.5 Importando arquivos Excel de maneira fácil\nA importação de arquivos Excel pode ser realizada em de forma fácil no RStudio seguindo os seguintes passos(Figura 3.4).\n\nAcessar aba Environment;\nClicar no ícone Import Dataset;\nIr em From Excel;\nSelecionar o arquivo em Browse;\nSelecionar a aba do arquivo (quando ouver mais de uma) no campo Sheet;\nCriar um nome para o objeto em Name;\nClicar no botão Import.\n\n\n\n\n\n\n\nFigura 3.4: Importando arquivos excel utilizando a interface RStudio. Os passos de 1 a 7 estão ilustrados na figura.\n\n\n\n\n\n3.2.6 Copiando e colando os dados\nConjuntos de dados podem ser importados para o R pelo método “copia e cola” para isso:\n\nSelecione as linhas e colunas da planilha que deseja copiar;\nNo R, execute o seguinte comando para colar os dados da área de transferência como um objeto no R:\n\n\ndados &lt;- read.delim2(\"clipboard\")\n#em mac:\ndados &lt;- read.delim2(pipe(\"pbpaste\"))\n\n\n\n3.2.7 Visualização geral do conjunto de dados\nApós realizar a importação, é muito importante verificar se não houveram problemas na importação. podemos utilizar algumas funções para verificar a estrutura dos dados. Uma função excelente para isso é a função str():\n\nstr(pinguins)\n\ntibble [333 × 7] (S3: tbl_df/tbl/data.frame)\n $ especie  : chr [1:333] \"Adelia\" \"Adelia\" \"Adelia\" \"Adelia\" ...\n $ ilha     : chr [1:333] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n $ bico_comp: num [1:333] 39.1 39.5 40.3 36.7 39.3 38.9 39.2 41.1 38.6 34.6 ...\n $ bico_prof: num [1:333] 18.7 17.4 18 19.3 20.6 17.8 19.6 17.6 21.2 21.1 ...\n $ nadadeira: num [1:333] 181 186 195 193 190 181 195 182 191 198 ...\n $ peso     : num [1:333] 3750 3800 3250 3450 3650 ...\n $ sexo     : chr [1:333] \"Macho\" \"Femea\" \"Femea\" \"Femea\" ...\n\n\nO objeto pinguins foi importado formato tibble. Esta é uma versão versão adaptada dos data frames em R que oferece algumas vantagens em relação aos data frames tradicionais, mas em geral podemos trabalhar com eles da mesma forma que fizemos co mdata frames no capítulo anterior.\nAo observar o str(), é importante verificarmos por exemplo:\n\nSe o número de linhas e colunas está correto;\nSe o tipo de variável (caracteres, numéricas) está correto.\n\nDiversas funções já conhecidas podem nos dar algumas informações sobre o conjunto de dados. Para isso, podemos:\n\nDigitar o nome do objeto ou utilizar a função View() para visualizá-lo (pelo menos as primeiras linhas);\nutilizar head() ou tail() para visualizar as primeiras linhas e últimas linhas do objeto.\nUtilizar colnames() para verificar os nomes das colunas (variáveis).\nUtilizar ncol(), nrow(), ou dim() para verificar o número de linhas e colunas\n\n\npinguins # visualiza o objeto pinguins no console\nView(pinguins) # abre o conjunto de dados em uma aba\nhead(pinguins) # ver as primeiras observações\ntail(pinguins)# ver as últimas observações\ncolnames(pinguins) # ver nomes das colunas\nncol(pinguins) # número de colunas\nnrow(pinguins) # número de linhas\ndim(pinguins) # Dimensões do objeto (linhas e colunas)\n\nPodemos utilizar a função table() para ter informações mais detalhadas sobre variáveis categóricas. Abaixo vamos:\n\nContar quantas observações (linhas) temos para cada espécie;\nContar quantas observações temos para cada espécie e sexo:\n\n\ntable(pinguins$especie)\n\n\n  Adelia Barbicha   Gentoo \n     146       68      119 \n\nwith(pinguins, table(especie, sexo)) # ou table(pinguins$especie, pinguins$sexo)\n\n          sexo\nespecie    Femea Macho\n  Adelia      73    73\n  Barbicha    34    34\n  Gentoo      58    61\n\n\nA função summary() fornece um resumo sobre a planilha:\n\nsummary(pinguins) # resumo da planilha\n\n   especie              ilha             bico_comp       bico_prof    \n Length:333         Length:333         Min.   :32.10   Min.   :13.10  \n Class :character   Class :character   1st Qu.:39.50   1st Qu.:15.60  \n Mode  :character   Mode  :character   Median :44.50   Median :17.30  \n                                       Mean   :43.99   Mean   :17.16  \n                                       3rd Qu.:48.60   3rd Qu.:18.70  \n                                       Max.   :59.60   Max.   :21.50  \n   nadadeira        peso          sexo          \n Min.   :172   Min.   :2700   Length:333        \n 1st Qu.:190   1st Qu.:3550   Class :character  \n Median :197   Median :4050   Mode  :character  \n Mean   :201   Mean   :4207                     \n 3rd Qu.:213   3rd Qu.:4775                     \n Max.   :231   Max.   :6300                     \n\n\nNo summary ou sumário da planilha podemos ver um resumo de cada variável do conjunto de dados. Para variáveis contínuas, Podemos observar medidas descritivas das variáveis contínuas, como valor mínimo e máximo, quartis, média e mediana.\n\n\n3.2.8 Alterando classe de variáveis\nVamos transformar as variavies categóricas em fatores com a função as.factor():\n\nstr(pinguins)\n\ntibble [333 × 7] (S3: tbl_df/tbl/data.frame)\n $ especie  : chr [1:333] \"Adelia\" \"Adelia\" \"Adelia\" \"Adelia\" ...\n $ ilha     : chr [1:333] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n $ bico_comp: num [1:333] 39.1 39.5 40.3 36.7 39.3 38.9 39.2 41.1 38.6 34.6 ...\n $ bico_prof: num [1:333] 18.7 17.4 18 19.3 20.6 17.8 19.6 17.6 21.2 21.1 ...\n $ nadadeira: num [1:333] 181 186 195 193 190 181 195 182 191 198 ...\n $ peso     : num [1:333] 3750 3800 3250 3450 3650 ...\n $ sexo     : chr [1:333] \"Macho\" \"Femea\" \"Femea\" \"Femea\" ...\n\npinguins$especie &lt;- as.factor(pinguins$especie)\npinguins$ilha &lt;- as.factor(pinguins$ilha)\npinguins$sexo &lt;- as.factor(pinguins$sexo)\n\nstr(pinguins) # as variaveis modificadas agora são fatores\n\ntibble [333 × 7] (S3: tbl_df/tbl/data.frame)\n $ especie  : Factor w/ 3 levels \"Adelia\",\"Barbicha\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ ilha     : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bico_comp: num [1:333] 39.1 39.5 40.3 36.7 39.3 38.9 39.2 41.1 38.6 34.6 ...\n $ bico_prof: num [1:333] 18.7 17.4 18 19.3 20.6 17.8 19.6 17.6 21.2 21.1 ...\n $ nadadeira: num [1:333] 181 186 195 193 190 181 195 182 191 198 ...\n $ peso     : num [1:333] 3750 3800 3250 3450 3650 ...\n $ sexo     : Factor w/ 2 levels \"Femea\",\"Macho\": 2 1 1 1 2 1 2 1 2 2 ...\n\nsummary(pinguins)\n\n     especie           ilha       bico_comp       bico_prof       nadadeira  \n Adelia  :146   Biscoe   :163   Min.   :32.10   Min.   :13.10   Min.   :172  \n Barbicha: 68   Dream    :123   1st Qu.:39.50   1st Qu.:15.60   1st Qu.:190  \n Gentoo  :119   Torgersen: 47   Median :44.50   Median :17.30   Median :197  \n                                Mean   :43.99   Mean   :17.16   Mean   :201  \n                                3rd Qu.:48.60   3rd Qu.:18.70   3rd Qu.:213  \n                                Max.   :59.60   Max.   :21.50   Max.   :231  \n      peso         sexo    \n Min.   :2700   Femea:165  \n 1st Qu.:3550   Macho:168  \n Median :4050              \n Mean   :4207              \n 3rd Qu.:4775              \n Max.   :6300              \n\n\nObserve que agora temos mais informações sobre as variáveis categóricas.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos de dados e importação</span>"
    ]
  },
  {
    "objectID": "c04_EstDescritiva.html",
    "href": "c04_EstDescritiva.html",
    "title": "4  Estatísticas descritivas",
    "section": "",
    "text": "4.1 Medidas de posição e dispersão\nVamos calcular estatísticas descritivas para a coluna correspondente ao comprimento do bico\npinguins$bico_comp #comprimento do bico para cada indivíduo\nUtilizaremos as seguintes funções para calcular as estatísticas descritivas:\nmean(pinguins$bico_comp) #média\n\n[1] 43.99279\n\nmedian(pinguins$bico_comp)#mediana\n\n[1] 44.5\n\nvar(pinguins$bico_comp) #variância\n\n[1] 29.90633\n\nsd(pinguins$bico_comp) #desvio padrão\n\n[1] 5.468668\n\nsummary(pinguins$bico_comp) #mínimo, máximo, mediana, média e 1º e 3º quartis\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  32.10   39.50   44.50   43.99   48.60   59.60\nQuantis: podemos utilizar a função quantile() para calcular os quartis ou percentis. Nessa função, o argumento probs pode ser usado para incluir os percentis que vamos calcular. Se não usarmos nenhum valor específico, obteremos aos percentis 0% (menor valor), primeiro quartil (25%), mediana ou segundo quartil (50%), terceiro quartil (75%) e percentil 100% (maior valor):\nquantile(pinguins$bico_comp) \n\n  0%  25%  50%  75% 100% \n32.1 39.5 44.5 48.6 59.6 \n\n# escolher percentis:\nquantile(pinguins$bico_comp, probs = c(0.1,0.9))\n\n 10%  90% \n36.6 50.8",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estatísticas descritivas</span>"
    ]
  },
  {
    "objectID": "c04_EstDescritiva.html#medidas-de-posição-e-dispersão",
    "href": "c04_EstDescritiva.html#medidas-de-posição-e-dispersão",
    "title": "4  Estatísticas descritivas",
    "section": "",
    "text": "mean(): cálculo da média;\nmedian(): cálculo da mediana;\nvar(): cálculo da variância;\nsd(): cálculo do desvio padrão;\nsummary(): cálculo de diversas estatísticas descritivas.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estatísticas descritivas</span>"
    ]
  },
  {
    "objectID": "c04_EstDescritiva.html#calculando-estatísticas-descritivas-para-múltiplas-variáveis-ou-grupos-de-valores",
    "href": "c04_EstDescritiva.html#calculando-estatísticas-descritivas-para-múltiplas-variáveis-ou-grupos-de-valores",
    "title": "4  Estatísticas descritivas",
    "section": "4.2 Calculando estatísticas descritivas para múltiplas variáveis ou grupos de valores",
    "text": "4.2 Calculando estatísticas descritivas para múltiplas variáveis ou grupos de valores\nAlgumas funções podem ser usadas para facilitar a aplicação de funções de forma simultânea em diferentes colunas ou grupos de dados.\n\n4.2.1 Função tapply()\nComo temos espécies diferentes, vamos calcular a média e desvio padrão do comprimento do culmen para cada uma das espécies utilizando a função tapply().\n\n#média\ntapply(pinguins$bico_comp, #coluna com os valores\n       pinguins$especie, #coluna com a espécie\n       mean) # função a ser aplicada\n\n  Adelia Barbicha   Gentoo \n38.82397 48.83382 47.56807 \n\n#desvio padrão\ntapply(pinguins$bico_comp, pinguins$especie, sd) \n\n  Adelia Barbicha   Gentoo \n2.662597 3.339256 3.106116 \n\n\n\n\n4.2.2 Função apply()\nEsta função pode ser usada para aplicar outra função para cada coluna de um conjunto de dados. Se quisermos calcular a média em todas as colunas numéricas, podemos calcular em uma por uma, ou utlizar a função apply() para aplicar a função média para todas as colunas\n\n#média de de uma das colunas\napply(pinguins[,3:6], 2, mean) #Calcular a média para todas as colunas\n\n bico_comp  bico_prof  nadadeira       peso \n  43.99279   17.16486  200.96697 4207.05706 \n\n\n\n\n4.2.3 Função aggregate()\nEsta função é muito útil quando queremos calcular estatísticas descritivas e temos uma ou mais colunas de fatores que agrupam os dados. Se quisermos calcular as médias para cada uma das variáveis numéricas da planilha pinguins para cada uma das espécies usando aggregate():\n\naggregate(cbind(bico_comp,bico_prof,nadadeira,peso) ~ especie, #inagregar variaveis numéricas por espécie\n          data = pinguins, # selecionar as variáveis\n          mean) # função a ser aplicada\n\n   especie bico_comp bico_prof nadadeira     peso\n1   Adelia  38.82397  18.34726  190.1027 3706.164\n2 Barbicha  48.83382  18.42059  195.8235 3733.088\n3   Gentoo  47.56807  14.99664  217.2353 5092.437\n\n\nPodemos fazer isso também utilizando ambos os fatores, espécie e sexo:\n\naggregate(cbind(bico_comp, bico_prof, nadadeira, peso)~especie+sexo,data = pinguins, mean) #agregando por espécie e sexo",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estatísticas descritivas</span>"
    ]
  },
  {
    "objectID": "c04_EstDescritiva.html#dados-faltantes",
    "href": "c04_EstDescritiva.html#dados-faltantes",
    "title": "4  Estatísticas descritivas",
    "section": "4.3 Dados faltantes",
    "text": "4.3 Dados faltantes\nUm grande problema em cnjuntos de dados reais são os dados faltantes. A forma de lidar com valores faltantes dependerá da natureza deles, da forma que os dados serão analisados e das perguntas a serem feitas sobre os dados.\nVamos exemplificar a análise em uma versão do conjunto de dados pinguins ampliada, que apresenta dados faltantes:\n\npinguins.na &lt;- read_excel(\"Bioestat_PPGBio.xlsx\", sheet = \"pinguins.na\")\n\nAo observar o conjunto de dados, identificamos diversos valores faltantes. Um problema causado por isso é que algumas funções não irão funcionar normalmente. no exemplo, vamos tentar calcular a média do comprimento do culmen (culmen_comp_mm):\n\npinguins.na$culmen_comp_mm\nmean(pinguins.na$culmen_comp_mm)\n\nObservamos que ela não é calculada. No help da função média, conseguimos identificar um argumento que pode nos ajudar. O argumento na.rm, que no padrão da função está como na.rm = FALSE, permite que ela desconsidere os NAs quando na.rm = TRUE:\n\nmean(pinguins.na$culmen_comp_mm, na.rm = TRUE)\n\nExistem diversas formas de tratar dados faltantes. Caso queira remover todas as observações (linhas) que apresentem dados faltantes, a função na.omit() permite remover todas as colunas com dados faltantes:\n\ndim(pinguins.na) #num. de linhas e colunas do objeto\n\n[1] 344   7\n\n#criar novo objeto (pinguins.narm) sem linhas com NA\npinguins.narm &lt;- na.omit(pinguins.na) \n\ndim(pinguins.narm) #dimensões do novo objeto\n\n[1] 333   7",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estatísticas descritivas</span>"
    ]
  },
  {
    "objectID": "c04_EstDescritiva.html#tabelas-sofisticadas-com-table1",
    "href": "c04_EstDescritiva.html#tabelas-sofisticadas-com-table1",
    "title": "4  Estatísticas descritivas",
    "section": "4.3 Tabelas sofisticadas com table1()",
    "text": "4.3 Tabelas sofisticadas com table1()\nCom o pacote table1, é possivel preparar facilmente uma tabela de estatísticas descritivas como a Tabela 4.1 . No exemplo, iremos gerar uma tabela com estatísticas descritivas para as variáveis numéricas do conjunto de dados, calculando elas em separado para cada espécie de pinguim:\n\nlibrary(table1)\n\n\nAttaching package: 'table1'\n\n\nThe following objects are masked from 'package:base':\n\n    units, units&lt;-\n\ncolnames(pinguins) # verificar colunas para escolher\n\n[1] \"especie\"   \"ilha\"      \"bico_comp\" \"bico_prof\" \"nadadeira\" \"peso\"     \n[7] \"sexo\"     \n\n#tabela de variaveis numericas por especie\ntable1(~ bico_comp + bico_prof + nadadeira + peso | especie , data = pinguins)\n\n\n\nTabela 4.1: estatísticas descritivas para o conjunto de dados “pinguins”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdelia\n(N=146)\nBarbicha\n(N=68)\nGentoo\n(N=119)\nOverall\n(N=333)\n\n\n\n\nbico_comp\n\n\n\n\n\n\nMean (SD)\n38.8 (2.66)\n48.8 (3.34)\n47.6 (3.11)\n44.0 (5.47)\n\n\nMedian [Min, Max]\n38.9 [32.1, 46.0]\n49.6 [40.9, 58.0]\n47.4 [40.9, 59.6]\n44.5 [32.1, 59.6]\n\n\nbico_prof\n\n\n\n\n\n\nMean (SD)\n18.3 (1.22)\n18.4 (1.14)\n15.0 (0.986)\n17.2 (1.97)\n\n\nMedian [Min, Max]\n18.4 [15.5, 21.5]\n18.5 [16.4, 20.8]\n15.0 [13.1, 17.3]\n17.3 [13.1, 21.5]\n\n\nnadadeira\n\n\n\n\n\n\nMean (SD)\n190 (6.52)\n196 (7.13)\n217 (6.59)\n201 (14.0)\n\n\nMedian [Min, Max]\n190 [172, 210]\n196 [178, 212]\n216 [203, 231]\n197 [172, 231]\n\n\npeso\n\n\n\n\n\n\nMean (SD)\n3710 (459)\n3730 (384)\n5090 (501)\n4210 (805)\n\n\nMedian [Min, Max]\n3700 [2850, 4780]\n3700 [2700, 4800]\n5050 [3950, 6300]\n4050 [2700, 6300]\n\n\n\n\n\n\n\n\n\n\nPodemos utilizar mais de um fator para separar as espécies, veja o exemplo a seguir como separar as estatísticas descritivas por espécie e por sexo:\n\n#tabela de variaveis numericas por especie e sexo\ntable1(~culmen_comp_mm + culmen_prof_mm+nadadeira_comp_mm+peso_g|especie+sexo , data = pinguins, overall = NULL)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estatísticas descritivas</span>"
    ]
  },
  {
    "objectID": "c06_Graficos.html",
    "href": "c06_Graficos.html",
    "title": "6  Gráficos e análise exploratória de dados",
    "section": "",
    "text": "6.1 Análise exploratória de dados\nO conceito de análise exploratória de dados (Exploratory Data Analysis - EDA) foi introduzido por John Tuckey, e enfatiza estratégias de entender os dados por meio de observação de estatísticas descritivas e exploração gráfica Ellison (2001). Neste tópico, vamos aplicar algumas dessas ferramentas em uma planilha de dados. Neste script, introduziremos alguns instrumentos de EDA e elaboração de gráficos.\nPrimeiramente, lembrem-se de criar um novo diretório (pasta), colocar as planilhas que serão importadas nele e definní-lo como diretório de trabalho com setwd().\nVamos utilizar novamente a planilha pinguins. Dê uma visualizada geral para lembrar dela:\n#primeiramente, definir diretório de trabalho com setwd()\nlibrary(readxl) #carregar pacote readxl \npinguins &lt;- read_excel(\"dados_R.xlsx\", sheet = \"pinguins\")\nhead(pinguins)# observar as primeiras linhas de iris\nstr(pinguins) #observar a estrutura do objeto\nsummary(pinguins) #estatísticas sumárias do objeto iris\nPodemos calcular estatísticas descritivas como visto na aula anterior (Tabela 6.1). Nesse exemplo, a fórmula foi simplificada:\n#install.packages(\"table1\") #caso não tenha sido instalado\nlibrary(table1) # carregar o pacote\n\n#criar tabela com estatísticas descritivas para todas as variáveis numéricas\ntable1(~ . | especie , data = pinguins[,c(1,3:6)])\n\n\n\nTabela 6.1: estatísticas descritivas para o conjunto de dados “pinguins”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdelia\n(N=146)\nBarbicha\n(N=68)\nGentoo\n(N=119)\nOverall\n(N=333)\n\n\n\n\nbico_comp\n\n\n\n\n\n\nMean (SD)\n38.8 (2.66)\n48.8 (3.34)\n47.6 (3.11)\n44.0 (5.47)\n\n\nMedian [Min, Max]\n38.9 [32.1, 46.0]\n49.6 [40.9, 58.0]\n47.4 [40.9, 59.6]\n44.5 [32.1, 59.6]\n\n\nbico_prof\n\n\n\n\n\n\nMean (SD)\n18.3 (1.22)\n18.4 (1.14)\n15.0 (0.986)\n17.2 (1.97)\n\n\nMedian [Min, Max]\n18.4 [15.5, 21.5]\n18.5 [16.4, 20.8]\n15.0 [13.1, 17.3]\n17.3 [13.1, 21.5]\n\n\nnadadeira\n\n\n\n\n\n\nMean (SD)\n190 (6.52)\n196 (7.13)\n217 (6.59)\n201 (14.0)\n\n\nMedian [Min, Max]\n190 [172, 210]\n196 [178, 212]\n216 [203, 231]\n197 [172, 231]\n\n\npeso\n\n\n\n\n\n\nMean (SD)\n3710 (459)\n3730 (384)\n5090 (501)\n4210 (805)\n\n\nMedian [Min, Max]\n3700 [2850, 4780]\n3700 [2700, 4800]\n5050 [3950, 6300]\n4050 [2700, 6300]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Gráficos e análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "c06_Graficos.html#análise-exploratória-de-dados",
    "href": "c06_Graficos.html#análise-exploratória-de-dados",
    "title": "6  Gráficos e análise exploratória de dados",
    "section": "",
    "text": "Somente foram incluídas as colunas de interesse no argumento data = pinguins[,c(1,3:6)]. Desta forma selecionamos as colunas 1, 3, 4, 5 e 6, que representam a variével espécie e as variáveis numéricas;\nA fórmula foi apresentada como ~ . | especie. O ponto indica que iremos incluir todas as variáveis dos nossos dados agrupadas por espécie.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Gráficos e análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "c06_Graficos.html#gráficos",
    "href": "c06_Graficos.html#gráficos",
    "title": "6  Gráficos e análise exploratória de dados",
    "section": "6.2 Gráficos",
    "text": "6.2 Gráficos\nO objetivo deste tópico é introduzir o ambiente gráfico do R, e compreender suas principais funções.\n\n6.2.1 Função plot: preparando gráficos de dispersão (scatterplots)\nPodemos verificar se há alguma relação antre o comprimento do culmen (bico_comp) e a profundidade do culmen (bico_prof) com a função plot() (Figura 6.1)\n\nplot(bico_comp ~ bico_prof, data = pinguins)\n\n\n\n\n\n\n\nFigura 6.1: gráfico de dispersão entre o comprimento do bico (mm) e a profundidade do bico (mm)\n\n\n\n\n\n\n6.2.1.1 Argumentos\nA função plot() apresenta diversos argumentos que podem ser utilizados para fazer modificações nos gráficos. Para observar a ajuda para esses parâmetros, observe as ajudas da função plot() e par(). Podemos por exemplo, mudar o formato dos pontos com o argumento pch, e a cor com col.\nA função colors() mostra as cores disponíveis. Para ver os tipos de pontos disponíveis (Figura 6.2).\n\n#usar install.packages(\"ggpubr\") #para instalar o pacote\nggpubr::show_point_shapes() # mostra os tipos de pontos disponíveis para o argumento pch.\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\n\nFigura 6.2: formatos de pontos disponíveis visualizados com o pacote ggpubr\n\n\n\n\n\nDiversos parâmetros podem ser alterados, como nos exemplo abaixo.\n\nxlab e ylab: alteram o texto dos eixos x e y;\nmain: alteram o título do gráfico;\nxlim e ylim: alteram os limites máximos e mínimos dos eixos x e y.\n\nAbaixo, os argumentos da função plot foram divididos em linhas e o efeito de cada argumento foi descrito após o #.\n\nplot(bico_comp ~ bico_prof, data = pinguins,\n     xlab = \"Profundidade do culmen (mm)\", # muda o nome do eixo x \n     ylab = \"Comprimento do culmen (mm)\",# muda o nome do eixo y\n     main = \"Comparando o culmen em pinguins\", #coloca título no gráfico\n     xlim = c(0,22), #muda limites do eixo x c(0,22) coloca o valor mínimo 0 e máximo 8\n     ylim = c(0,60)) #muda limites do eixo y\n\nSabemos que há 3 espécies de pinguins no conjunto de dados que tal colorir os pontos por espécie? Para isso incluímos o argumento col ( Figura 6.3)\n\n#gráfico colorido por espécie\nplot(bico_comp ~ bico_prof, data = pinguins, col = as.factor(especie))\n\n#para escolher as cores\ncores &lt;- c(\"red\", \"blue\", \"green\") # cria um vetor com 1 cor para cada espécie\ncores[as.factor(pinguins$especie)] # distribui as cores entre as observações de especie\n\n#Para colorir com as cores que queremos, colocamos col = cores[as.factor(pinguins$especie)]:\nplot(bico_comp ~ bico_prof, data = pinguins, col = cores[as.factor(pinguins$especie)])\n\n\n\n\n\n\n\nFigura 6.3: gráfico de dispersão colorido por espécie\n\n\n\n\n\nPodemos incluir uma legenda no gráfico com a função legend (Figura 6.4).\n\npontos &lt;- c(1,3,17) # cria vetor com 1 tipo de ponto para cada espécie\npontos[as.factor(pinguins$especie)]\n\n#plotar a figura\nplot(bico_comp ~ bico_prof, data = pinguins, \n     pch = pontos[as.factor(pinguins$especie)])\n\n#criar as legendas\nlegend(13, 60, #coordenadas x e y da legenda\n       legend = levels(as.factor(pinguins$especie)), # texto da legenda (nomes espécies)\n       pch = pontos, # pontos\n       bty = \"n\")  # legenda sem caixa\n\n\n\n\n\n\n\nFigura 6.4: gráfico de dispersão incluindo legendas e diferentes formatos de pontos\n\n\n\n\n\nPara selecionar somente os dados de Adelia, podemos utilizar o argumento subset da função plot()(Figura 6.5).\n\nplot(bico_comp ~ bico_prof, data = pinguins, subset = especie == \"Adelia\")\n\n\n\n\n\n\n\nFigura 6.5: gráfico de dispersão com as dimensções dos bicos de pinguins utilizando o subconjunto dos dados de pinguins de Adélia.\n\n\n\n\n\n\n\n\n6.2.2 Histogramas e gráficos ramo-e-folha\nHistogramas são gráficos univariados de frequência de valores, interessantes para observar como uma variável está distribuia. O R apresenta a função hist() para criar histogramas.\nVamos observar a distribuição dos dados da variável peso_g (Figura 6.6).\n\n?hist # help da função hist\nhist(pinguins$peso) \n\n\n\n\n\n\n\nFigura 6.6: histograma da variável peso_g\n\n\n\n\n\nUm problema dos histogramas é que as categorias de valores (número de barras) do eixo x são arbitrárias. Você pode escolher a quantidade de categorias com o argumento breaks (Figura 6.7)\n\nhist(pinguins$peso, col = \"grey\", breaks = 30) #mudando o número de barras\n\n\n\n\n\n\n\nFigura 6.7: histograma alterando o número de categorias.\n\n\n\n\n\nOs diagramas de ramo e folha seguem a mesma lógica do histograma, entretanto ele apresenta os valores observados:\n\nstem(pinguins$bico_comp)\n\n\n  The decimal point is at the |\n\n  32 | 115\n  34 | 045660012355677799\n  36 | 0000222344556677890022333566677788899\n  38 | 11112235666788899000122235556666677778\n  40 | 122233556666788999901111111334455678\n  42 | 001223455567788991222233455568\n  44 | 01145990111222222334455555667778889\n  46 | 001112222344445555566778888990223455556678\n  48 | 1122444555677780001112233455566678889\n  50 | 000001122234455555677888899011333345579\n  52 | 00012257845\n  54 | 23189\n  56 | \n  58 | 06\n\n\n\n\n6.2.3 Boxplots\nBoxplots (diagramas de caixa) nos permitem observar a variação dos dados e comparar amostras. Esses diagramas geralmente exibem valores máximos e mínimos (excluindo valores extremos) entre as hastes, o primeiro e terceiro quartis dos dados (50% dos valores) dentro da caixa, a mediana como a linha do meio e pontos para os outliers. Podemos criar esses diagramas com a função boxplot() (Figura 6.8).\n\nboxplot(pinguins[,3:6]) # diagrama de caixas das variáveis numéricas de iris\n\n\n\n\n\n\n\nFigura 6.8: gráfico do tipo boxplot para as variáveis numéricas do conjunto de dados de pinguins.\n\n\n\n\n\nPodemos usar fórmulas com “~” (que pode ser lido como “em função de”) para observar as diferenças entre as espécies de pinguins para cada uma das variáveis. No caso, fazemos um boxplot de peso por especie (Figura 6.9).\n\nboxplot(peso ~ especie, data=pinguins, col = c(2,3,5)) # incluindo 'col' para mudar as cores das caixas\n\n\n\n\n\n\n\nFigura 6.9: boxplot de peso em função da espécie para o conjunto de dados de pinguins.\n\n\n\n\n\nObservamos diferenças entre as espécies\n\n\n6.2.4 Gráficos de pizza e gráficos de barras.\nVamos fazer um gráfico de pizza da quantidade de amostras por ilha no conjunto de dados pinguins (Figura 6.10). O total de amostars por ilha pode ser calculado com a função table(), e depois os gráficos podem ser plotados com o resultado:\n\nn_ilha &lt;- table(pinguins$ilha) #tabela com número de observações\nn_ilha\n\n\n   Biscoe     Dream Torgersen \n      163       123        47 \n\n\n#gráfico de pizza e gráfico de barras\npie(n_ilha)\nbarplot(n_ilha)\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigura 6.10: gráfico de pizza (a) e gráficos de barras (b).\n\n\n\n\n\n6.2.5 Colocando vários gráficos em uma mesma figura\nVamos fazer boxplots diferenciando as espécies para as 4 variáveis medidas nos pinguins. Para incluir os 4 em uma única prancha, podemos alterar parâmetros gráficos da área de plotagem do R.\nA função par() altera parâmetros gráficos. Com o argumento mfrow escolhemos o número de linhas e colunas que terão na figura Com par(mfrow = c(2,2)), incluímos 4 gráficos (2 na linha e 2 na coluna).\nTambém utilizamos par(mar= c(2,2,1,1)) para alterar as margens de cada gráfico e preencher melhor a figura. Cada um dos 3 valores no vetor representa uma das margens da figura (Figura 6.11)\n\npar(mfrow = c(2,2)) #inicia gráfico com 4 figuras c(2,2) : organiza em 2 linhas e 2 colunas\npar(mar=c(2,2,1,1)) # altera o tamanho das margens para gráficos. Ajuda na visualização\nboxplot(bico_comp ~ especie, data=pinguins, col = c(2,3,5)) # boxplot Sepal.Length~Species\nboxplot(bico_prof ~ especie, data=pinguins, col = c(2,3,5)) # boxplot Sepal.Width~Species\nboxplot(nadadeira ~ especie, data=pinguins, col = c(2,3,5)) # boxplot Petal.Length~Species\nboxplot(peso ~ especie, data=pinguins, col = c(2,3,5)) # boxplot Petal.Width~Species\n\n\n\n\n\n\n\nFigura 6.11: juntando 4 gráficos em uma figura.\n\n\n\n\n\nAtenção: após usar o par(), todos os gráficos que fizer serão plotados com esses parâmetros. Para reverter isso, digite os comandos par(mfrow=c(1,1)) ou dev.off().\n\n\n6.2.6 Matriz de gráficos de dispersão com pairs()\nQuando queremos estudar diversas variávies para tentar verificar relações entre elas, podemos usar a função pairs() para observar plotes y ~ x entre todas as variáveis (Figura 8.7).\n\npairs(pinguins[,3:6]) #variáveis de iris plotadas em pares\npairs(pinguins[,3:6], \n      col = as.factor(pinguins$especie), # colorir por espécie\n      lower.panel = NULL) # plotar somente o painel superior\n\n\n\n\n\n\n\nFigura 6.12: diagrama de gráficos de dispersão.\n\n\n\n\n\nDica: caso a figura fique pequena, digite x11() para abrir uma janela gráfica antes de realizar uma plotagem.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Gráficos e análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "c06_Graficos.html#gráficos-com-ggplot2",
    "href": "c06_Graficos.html#gráficos-com-ggplot2",
    "title": "6  Gráficos e análise exploratória de dados",
    "section": "6.3 Gráficos com ggplot2",
    "text": "6.3 Gráficos com ggplot2\nAs capacidades gráficas do R podem ser expandidas de forma expressiva com a utilização de pacotes. Um O pacote ggplot2 permite a preparação de gráficos com qualidade de publicação de maneira fácil. O pacote utiliza uma linguagem diferente da forma tradicional para a elaboração de gráficos no R, conhecida como gramática dos gráficos Wilkinson & Wills (2005); (wilkinsonGrammarGraphics2005?). No ggplot2, cada elemento gráfico é adicionado como uma camada.\nEm geral, a estrutura do gráfico no ggplot2 irá seguir uma estrutura geral, na qual vamos adicionando complexidade para or gráficos em diferenteas camadas. As camadas podem ser adicionadas utilizando funções:\n\nCriar novo ggplot: isso pode ser realizado utilizando a função ggplot(). Nela também podemos adicionar como argumentos o conjunto e dados a ser utilizado e també a estética (aesthetics; função aes()).\nAdicionar a estética (aesthetics): é adicionada pela função aes(). Os argumentos a serem adicionados variam dependendo do gráfico, mas podm incluir as variáveis a serem plotadas nos eixos (argumentos x = e y =), cores e preencchimentos (col = e fill =), formato de pontos ou tipos de linhas (pch = e linetype =) ou fatores de agrupamento (group =).\nAdicionar geometria (geom): a geometria definiria o tipo de gráfico, como gráficos de barras (geom_bar()), histogramas(geom_histogram()) boxplot (geom_boxplot()), gráficos de dispersão (geom_point())\nParâmetros adicionais: outros parâmetros podem ser adicionados. Eles podem alterar características como títulos (ggtitle()), etiquetas dos eixos (xlab() e ylab()), ou temas (funções theme_…()).\n\nPrimeiramente, vamos instalar e carregar o pacote ggplot2:\n\n#install.packages(\"ggplot2\") # se o pacote não estiver instalado\nlibrary(ggplot2) #carregar o pacote\n?ggplot2 # informações sobre o pacote\n\n\n6.3.1 Gráficos de dispersão\nVamos exemplificar o funcionamento do ggplot criandocom um gráfico de dispersão passo a passo. Primeiramente, utilizaremos a função ggplot() para criar um novo gráfico com os dados de pinguins (Figura 6.13).\n\nggplot(pinguins)\n\n\n\n\n\n\n\nFigura 6.13: primeira camada do ggplot.\n\n\n\n\n\nA função simplesmente criou o a primeira camada do gráfico. Agora, podemos adicionar dentro da função ggplot uma estética com a função aes() (Figura 6.14). Vamos adicionar o comprimento do culmen no eixo x e o peso no eixo y.\n\nggplot(pinguins, aes(x = nadadeira, y = peso))\n\n\n\n\n\n\n\nFigura 6.14: adicionando a estética com aes()\n\n\n\n\n\nNeste passo, agra temos as escalas dos eixos x e y. Agora, vamos incluir uma geometria. Como queremos um gráfico de dispersão, vamos usar a função geom_point() para adicionar os pontos. A nova camada é adicionada incluindo um + e adicionando a nova função na próxima linha (Figura 6.15).\n\nggplot(pinguins, aes(x = nadadeira, y = peso))+\n  geom_point()\n\n\n\n\n\n\n\nFigura 6.15: adicionando camada com pontos com geom_point()\n\n\n\n\n\nPodemos também modificar o gráfico de diversas formas (Figura 6.16):\n\nLinha de regressão linear (modelo linear - lm) com a função geom_smooth();\nAlterar a estética aes(): colorir os pontos em função da espécie (argumento col =) e mudar os formatos emfunção do sexo (argumento shape =)\nTítulo e nomes dos eixos com funções labs(), xlab() e ylab(). Vamos alterar também o título da legenda de col de “especie” para “Espécie” e a legenda de shape de “sexo” para “Sexo”.\nMudar o tema com uma das funções theme_…().\n\n\nggplot(pinguins, aes(x = nadadeira, y = peso))+\n  geom_point(aes(col = especie, shape = sexo))+\n  geom_smooth(method = \"lm\")+\n  labs(title = \"Pinguins de Adélia\", \n       subtitle = \"Gráfico de dispersão: peso ~ comprimento da nadadeira\", col = \"Espécie\", shape = \"Sexo\")+\n  xlab(\"Comprimento da nadadeira (mm)\")+\n  ylab(\"Peso (g)\")+\n  theme_light()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigura 6.16: alterando parâmetros do gráfico do ggplot2.\n\n\n\n\n\nPerceba que o argumento aes() pode ser utilizado junto com a função ggplot() para definir a estética da figura como um todo, ou coma função geom_…(), para somente alterar a estética da geometria. Vamos alterar a gigura acima para criar uma linha de regressão de cor diferente para cada cada espécie. Para isso, somente iremos incluir o argumento col na estética do ggplot(), e não somente do geom_point() como estava no exemplo anterior (Figura 6.17).\n\nggplot(pinguins, aes(x = nadadeira, y = peso, col = especie))+\n  geom_point(aes(shape = sexo))+\n  geom_smooth(method = \"lm\")+\n  labs(title = \"Pinguins de Adélia\", \n       subtitle = \"Gráfico de dispersão: peso ~ comprimento da nadadeira\", col = \"Espécie\", shape = \"Sexo\")+\n  xlab(\"Comprimento da nadadeira (mm)\")+\n  ylab(\"Peso (g)\")+\n  theme_light()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigura 6.17: alterando parâmetros do gráfico do ggplot2. Linha de regressão separada para cada espécie.\n\n\n\n\n\n\n\n6.3.2 Incluindo facetas\nPodemos fazer gráficos separados em facetas utilizando algum fator de agrupamento. A função facet_wrap() separa facetas gráficos em relação a um fator, enquanto a função facet_grid() cria uma grade com gráficos. Nos exemplos abaixo, criamos um gráfico do peso em função do comprimento da nadadeira, separado em facetas por ilha, e no segundo exemplo o memso gráfico, só que com as faceta separadas em uma grade por sexo e por ilha (Figura 6.18).\n\n#gráfico incluindo facetas por ilha\nggplot(pinguins, aes(x = nadadeira, y = peso, col = especie))+\n  geom_point()+\n  facet_wrap(~ilha, scales =\"free\")\n\n#gráfico com grade por ilha e por sexo\nggplot(pinguins, aes(x = nadadeira, y = peso, col = especie))+\n  geom_point()+\n  facet_grid(sexo~ilha, scales =\"free\")\n\n\n\n\n\n\n\nFigura 6.18: gráficos separados por facetas.\n\n\n\n\n\n\n\n6.3.3 Histograma\nNo exemplo abaixo, criaremos um histograma com o ggplot2. Para isso utilizaremos a geometria geom_histogram(). Para isso, somente precisamos adicionar o argumento x, que representa a variável para qual queremos criar o histograma. O argumento bins = é usado para adicionar o número de categorias a ser usadas no histograma. No exemplo abaixo, criamos um gráfico simples (Figura 6.19 a), depois colorimos por espécie (Figura 6.19 b) e posteriormente, incluímos facetas por espécie e sexo (Figura 6.19 c).\n\nggplot(data = pinguins) + #cria um plot vazio\n  geom_histogram(aes(x = peso),bins = 30) \n\nggplot(data = pinguins) + #cria um plot vazio\n  geom_histogram(aes(x = peso, fill = especie),bins = 30) \n\nggplot(data = pinguins) + #cria um plot vazio\n  geom_histogram(aes(x = peso, fill = especie),bins = 30)+\n  facet_grid(especie ~ sexo)\n\n\n\n\n\n\n\n\n\n\n\n(a) histograma\n\n\n\n\n\n\n\n\n\n\n\n(b) adicionando preenchimento de cor por espécie\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) adicionando facetas por sexo e espécie\n\n\n\n\n\n\n\nFigura 6.19: histograma com o pacote ggplot2.\n\n\n\n\n\n\n6.3.4 Boxplot\nVamos criar boxplots com o ggplot2, primeiramente comparando as diferentes espécies (Figura 6.20 a). Podemos fazer boxplots mais complexos incluindo cores diferentes para os sexos (Figura 6.20 b), e separando facetas para cada localidade (Figura 6.20 c).\n\n#boxplot\nggplot(aes(y = peso,x = especie),data = pinguins) +\n  geom_boxplot() # adiciona a camada do boxplot\n\n#colorido por sexo\nggplot(aes(y = peso,x = especie, fill = sexo),data = pinguins) +\n  geom_boxplot() # adiciona a camada do boxplot\n\n#separado em facetas por ilha\nggplot(aes(y = peso, x = especie, fill = sexo), data = pinguins) +\n  geom_boxplot()+\n  facet_wrap(~ilha)\n\n\n\n\n\n\n\n\n\n\n\n(a) boxplot\n\n\n\n\n\n\n\n\n\n\n\n(b) boxplot adicionando preenchimento por sexo\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) boxplot adicionando facetas por ilha\n\n\n\n\n\n\n\nFigura 6.20: boxplot com ggplot2.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Gráficos e análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "c06_Graficos.html#gráfico-de-barras-com-errodesvio-padrão-com-ggpubr",
    "href": "c06_Graficos.html#gráfico-de-barras-com-errodesvio-padrão-com-ggpubr",
    "title": "6  Gráficos e análise exploratória de dados",
    "section": "6.4 Gráfico de barras com erro/desvio padrão com ggpubr",
    "text": "6.4 Gráfico de barras com erro/desvio padrão com ggpubr\nOutro gráfico comum é o gráfico de barras com barra de desvio padrão. Vamos fazer um gráfico com o peso dos pinguins por espécie, incluindo a barra de erros relativa ao desvio padrão. Para criar o gáfico de maneira fácil, utilizaremos o pacote ggpubr(). Neste gráfico, utilizamos a função ggbarplot(). Na função, temos os argumentos data para indicar o conjunto de dados, x para indicar o fator de agrupamento e y para indicar a variável quantitativa, e o argumento add = \"mean_sd\" para calcular a média e o desvio padrão (Figura 6.21). Também pode ser adicionado o argumento add = \"mean_se\" para adicionar o erro padrão.\n\nlibrary(ggpubr) # se não tiver instalado, install.packages(\"ggpubr\")\nggbarplot(data = pinguins, x = \"especie\", y = \"peso\", add = \"mean_sd\")\n\n\n\n\n\n\n\nFigura 6.21: gráfico de barras incluindo desvio padrão.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Gráficos e análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "c06_Graficos.html#salvando-gráficos",
    "href": "c06_Graficos.html#salvando-gráficos",
    "title": "6  Gráficos e análise exploratória de dados",
    "section": "6.5 Salvando gráficos",
    "text": "6.5 Salvando gráficos\nPodemos salvar uma figura utilizando o botão export na janela gráfica do RStudio. PAra criar uma imagem controlando detalhes dos parâmetros gráficos, uma boa opção é utilizar a função ggsave() do pacote ggplot2. Caso não seja especificado um objeto com a figura, a última figura plotada será salva (veja abaixo o exemplo 1). No exemplo 2, criamos um objeto com o plot e depois salvamos com a função ggsave() definindo os seguintes argumentos:\n\nfilename: nome do arquivo;\nplot: gráfico que será salvo;\ndevice: tipo de figura (“eps”, “ps”, “tex” (pictex), “pdf”, “jpeg”, “tiff”, “png”, “bmp”, “svg” ou “wmf” );\nwidth e height: dimensões (largura e altura) da figura;\nunits: unidade para as dimensões;\ndpi: resolução da figura.\n\n\n#exemplo 1\nggplot(pinguins, aes(x = nadadeira, y = peso, col = especie))+\n  geom_point()+\n  facet_grid(sexo~ilha, scales =\"free\")\nggsave(\"plot.pinguins.png\") #salva a última fgura plotada\n\n#exemplo 2\n ##criar objeto com a figura\nplot.pinguins &lt;- \nggplot(pinguins, aes(x = nadadeira, y = peso, col = especie))+\n  geom_point()+\n  facet_grid(sexo~ilha, scales =\"free\")\n\n ##salvar figura em pdf\nggsave(filename = \"plot.pinguins.png\", \n       plot = plot.pinguins, device = \"png\", \n       width = 25, height = 15, units = \"cm\", dpi = 400)\n\nA figura será salva no diretório de trabalho defindo, com o nome definido em filename. Lembrando que pode o diretório de trabalho onde a figura foi salva pode ser verificado com a função getwd().\n\n\n\n\nBehrens, J. T. (1997). Principles and procedures of exploratory data analysis. Psychological Methods, 2(2), 131160. https://doi.org/10.1037/1082-989X.2.2.131\n\n\nBrillinger, D. R. (2011). Data analysis, exploratory (pp. 530–537). SAGE Knowledge.\n\n\nEllison, A. M. (2001). Exploratory data analysis and graphical display (S. M. Scheiner & J. Gurevitch, Eds.; 2nd ed., pp. 37–62). Oxford University Press.\n\n\nWilkinson, L., & Wills, G. (2005). The grammar of graphics (2nd ed). Springer.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Gráficos e análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "c05_DistProbabilidade.html",
    "href": "c05_DistProbabilidade.html",
    "title": "5  Distribuições de Probabilidade",
    "section": "",
    "text": "5.1 Distribuição Normal",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Distribuições de Probabilidade</span>"
    ]
  },
  {
    "objectID": "c05_DistProbabilidade.html#distribuição-normal",
    "href": "c05_DistProbabilidade.html#distribuição-normal",
    "title": "5  Distribuições de Probabilidade",
    "section": "",
    "text": "5.1.1 Função de densidade de probabilidade com dnorm()\nA Função de Densidade de Probabilidade (FDP) da distribuição normal descreve a probabilidade de uma variável aleatória tomar um dado valor na distribuição normal. Assim, ela descreve o formato da curva.\nNo exemplo abaixo, podemos calcular a probabilidade de se observar os valores 0, 1 e 2 em uma distrinuição normal padrão (média = 0, desvio padrão = 1)\n\ndnorm(0, mean = 0, sd = 1) # = dnorm(0) ; mean = 0, sd = 1 estão implícitos\n\n[1] 0.3989423\n\ndnorm(1)\n\n[1] 0.2419707\n\ndnorm(2)\n\n[1] 0.05399097\n\n\nPodemos usar essa função para calcular e fazer um gráfico com a curva normal. Observe o exemplo abaixo, no qual fazemos um gráfico com valores entre -3 e 3, e a probabilidade de observá-los. Com isso, temos a formação de uma curva normal Figura 5.1 .\n\nz.scores &lt;- seq(-3,3,0.1) #gerar valores de -3 a 3, de 0.1 em 0.1\nvalor.d &lt;- dnorm(z.scores,0,1) # densidades de prpbabilidades dos valores-z\nplot(z.scores,valor.d, type = \"l\") #gráfico com as probabilidades observadas para os valores entre -3 e 3: forma a curva normal padrão \n\n\n\n\n\n\n\nFigura 5.1: Gráfico de densidade de probabilidades de uma distribuição normal\n\n\n\n\n\n\n\n5.1.2 Probabilidades com pnorm()\nPodemos usar a função pnorm para calcular a probabilidade de ocorrer um valor menor do que o valor-z observado.\nExemplo: qual é a probabilidade de ocorrer um indivíduo menor do que 30 cm em uma população de peixes na qual a média de tamanhos é 50cm e o desvio padrão é 15cm?\n\npnorm(q = 30, mean = 50, sd = 15) #~9%\n\n[1] 0.09121122\n\n\nNo oposto a probabilidade de se encontrar um indivíduo com mais de 30 cm é dada por 1 - (pnorm(q = 30, mean = 50, sd = 15)):\n\n1-pnorm(q = 30, mean = 50, sd = 15) # ~91%\n\n[1] 0.9087888\n\n#ou\npnorm(q = 30, mean = 50, sd = 15, \n      lower.tail = FALSE) #utilizando o argumento lower.tail.\n\n[1] 0.9087888\n\n\nAssim, podemos visualizar na Figura 5.2 os resultados obtidos pela função dnorm(), qnorm() e pnorm() na distribuição normal.\n\n\n\n\n\n\nFigura 5.2: Distribuição normal, mostrando as funções para calcular a densidade da probabilidade (dnorm), o quantil (qnorm) e a probabilidade (pnorm)\n\n\n\n\n\n5.1.3 Utilizando qnorm() para calcular quantis\nA função qnorm() calcula o valor da probabilidade a partir dos percentis. Podemos dizer que a função qnorm() faz o oposto do que faz a pnorm().\nExemplo: Vamos calcular o valor de tamanho que 9.12% dos indivíduos são menores, em uma população de peixes na qual a média de tamanhos é 50cm e o desvio padrão é 15cm?\n\nqnorm(p = 0.0912, mean = 50, sd = 15) # ~9.12% dos indivíduos tem &lt;30 cm\n\n[1] 29.99897\n\n#Probabilidade de se encontrar um indivíduo com menos de 30 cm:\npnorm(q = 30, mean = 50, sd = 15)\n\n[1] 0.09121122",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Distribuições de Probabilidade</span>"
    ]
  },
  {
    "objectID": "c05_DistProbabilidade.html#distribuição-binomial",
    "href": "c05_DistProbabilidade.html#distribuição-binomial",
    "title": "5  Distribuições de Probabilidade",
    "section": "5.2 Distribuição binomial",
    "text": "5.2 Distribuição binomial\nAdvém da Distribuição de Bernoulli. Nessa distribuição são realizadas N ensaios de Bernoulli, cada um com probabilidade de sucesso p constante. Um exemplo de um ensaio de Bernoulli é o lançamento de uma moeda e acertar cara ou coroa. Assim tempos uma probabilidade p de sucesso e 1-p de fracasso.\nA probabilidade de se obter X sucessos em n experimentos com probabilidade de sucesso p e de fracassos q é:\n\\(C^{x} _n p^{x}q^{n-x}\\)\nOnde \\(C^{x} _n\\) é dada pela combinação de n elementos tomados X a X:\n\\(C^{x}_n = \\big(\\begin{matrix}n \\\\x \\end{matrix}\\big)= \\frac{n!}{(n-x)!x!}\\)\nA probabilidade de se obter 5 caras em 10 lançamentos de moedas honestas (probabilidade de tirar cara = 0.5 e de tirar coroa = 0.5):\n\\(C^{5}_{10} = \\big(\\begin{matrix}10 \\\\5 \\end{matrix}\\big)= \\frac{10!}{(10-5)!5!}*0.5^5*0.5^5\\)\n\\(=252*0.03125*0.03125=0.2460938\\)\nEsse cálculo pode ser realizado no R utilizando o cálculo combinatório com a função choose(). Atenção, nos códigos apresentados abaixo, o texto de uma mesma função foi separado em mais de uma linha. Para executar o código no R, digite todas as informações de todas as linhas do código da função. Exemplo: choose(10,5) * 0.5^5 * 0.5^5, para executar o primeiro dos códigos abaixo.\n\nchoose(10,5)* # combinação de 10 elementos 5 a 5\n  0.5^5* # probabilidade de sucesso ^ número de sucessos\n  0.5^5 # probabilidade de fracassos elevado ao número de fracassos\n\n[1] 0.2460938\n\n\nPodemos realizar esse mesmo cálculo no R utilizando a função dbinom().\n\ndbinom(5, # número de sucessos que desejo obter\n       size = 10, # número de jogadas\n       prob = 0.5) # probabilidade de sucesso\n\n[1] 0.2460938\n\n\nA partir desse valor podemos calcular a probabilidade de se obter de 0 a 10 caras em uma jogada, conseguindo assim um gráfico da distribuição binomial:\n\nbindist &lt;- dbinom(0:10, size = 10, prob = 0.5) \nbindist # probabilidade de se obter 0, 1, 2, 3, ...,10 caras \n\n [1] 0.0009765625 0.0097656250 0.0439453125 0.1171875000 0.2050781250\n [6] 0.2460937500 0.2050781250 0.1171875000 0.0439453125 0.0097656250\n[11] 0.0009765625\n\nplot(0:10,bindist) #gráfico da distribuição binomial\n\n\n\n\n\n\n\nFigura 5.3: gráfico da distribuição binomial para x = 1:10, p = 0,5 e n =10\n\n\n\n\n\nQual é a probabilidade de se obter entre 0 e 5 caras em 10 jogadas?\n\npbinom(5,size = 10, prob = 0.5)\n\n[1] 0.6230469\n\n#ou\nsum(dbinom(0:5,size = 10, prob = 0.5))\n\n[1] 0.6230469",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Distribuições de Probabilidade</span>"
    ]
  },
  {
    "objectID": "c05_DistProbabilidade.html#distribuição-de-poisson",
    "href": "c05_DistProbabilidade.html#distribuição-de-poisson",
    "title": "5  Distribuições de Probabilidade",
    "section": "5.3 Distribuição de Poisson",
    "text": "5.3 Distribuição de Poisson\nA distribuição de poisson é uma distribuição de variável aleatória discreta. Ela é muito usada para descrever eventos raros ou dados de contagem, como por exemplo o número de espécimes encontrados em uma armadilha ou em uma parcela. Ela é descrevida por um único parâmetro \\(\\lambda\\). Sua aparência geral é de uma curva normal com desvio para um dos lados e uma cauda longa.\nExemplo: Digamos qua a quantidade de indivíduos de uma determinada espécies siga uma distribuição de Poisson. Há em média, 4 indivíduos de determinada espécie em uma parcela (ou seja, \\(\\lambda = 4\\)).\n\n#Qual a probabilidade de se encontrar 0 indivíduos em uma armadilha?\ndpois(0,4)\n\n[1] 0.01831564\n\n#Qual a probabilidade de se encontrar 3 ou menos indivíduos em uma armadilha?\nppois(3,4)\n\n[1] 0.4334701\n\n#ou\nsum(dpois(0:3,4))\n\n[1] 0.4334701\n\n\nO formato da distribuição de Poisson pode ser vista nos gráficos abaixo. Quando maior o \\(\\lambda\\), mais próximo simétrica ela fica (Figura 5.4)\n#Distribuição de Poisson: baixo lambda, cauda longa:\nplot(dpois(0:10, lambda = 2), type = \"l\") \n#Alto lambda, aproximação à normal:\nplot(dpois(0:30, lambda = 15), type = \"l\")\n\n\n\n\n\n\n\n\n\n\n\n(a) lambda = 2\n\n\n\n\n\n\n\n\n\n\n\n(b) lambda = 15\n\n\n\n\n\n\n\nFigura 5.4: Gráfico ilustrando a distribuição de Poisson com diferentes valores de \\(\\lambda\\)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Distribuições de Probabilidade</span>"
    ]
  },
  {
    "objectID": "c05_DistProbabilidade.html#gerando-sequências-e-dados-aleatórios",
    "href": "c05_DistProbabilidade.html#gerando-sequências-e-dados-aleatórios",
    "title": "5  Distribuições de Probabilidade",
    "section": "5.4 Gerando sequências e dados aleatórios",
    "text": "5.4 Gerando sequências e dados aleatórios\nO R é um ótimo instrumento para gerar dados aleatórios, que podem ser usados em simulações.\n\n5.4.1 Sequências numéricas e repetições\nPodemos gerar sequências numéticas com a notação “:” ou com a função seq():\n\n1:100 #gera sequência de 1 a 100\n\n#vamos fazer o mesmo com a função seq()\nseq(from = 1, # primeiro valor\n     to = 100, # último valor\n     by =1)  # espaço entre valores\n\nseq(1,10,0.1) # sequência de 1 a 10 a cada 0.1\n\nPodemos gerar repetições com a função rep():\n\nrep(1, times= 10)# repetir o número 1 10 vezes\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrep(c(1,2),10) # repetir o vetor (1,2) 10 vezes (total de elementos = 20)\n\n [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n\nrep(c(\"A\",\"B\"), each = 10) # repetir A 10x e depois B 10x\n\n [1] \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"B\" \"B\" \"B\" \"B\" \"B\" \"B\" \"B\" \"B\" \"B\"\n[20] \"B\"\n\n\nPodemos usar a função paste() para juntar dois valores. Exemplo: queremos criar um vetor com nomes de variáveis para 20 observações, 10 para um grupo controle e 10 para um tratamento:\n\npaste( #inicio a função paste\nc(rep(\"Controle\", times= 10),rep(\"Tratamento\", times= 10)),\nc(1:10,1:10) # crio uma numeração de 1:10 duas vezes\n)\n\n [1] \"Controle 1\"    \"Controle 2\"    \"Controle 3\"    \"Controle 4\"   \n [5] \"Controle 5\"    \"Controle 6\"    \"Controle 7\"    \"Controle 8\"   \n [9] \"Controle 9\"    \"Controle 10\"   \"Tratamento 1\"  \"Tratamento 2\" \n[13] \"Tratamento 3\"  \"Tratamento 4\"  \"Tratamento 5\"  \"Tratamento 6\" \n[17] \"Tratamento 7\"  \"Tratamento 8\"  \"Tratamento 9\"  \"Tratamento 10\"\n\n\nPodemos gerar números aleatórios a partir de uma distribuição teórica. Vamos gerar 100 observações a partir da distribuição normal, com média 10 e desvio padrão 2 utilizando a função rnorm():\n\n?rnorm #help da função\n#Gerar 100 observações de dados a partir da distribuição normal\n#média = 10 e sd = 2\nn10s2 &lt;- rnorm(100,10,2) #rnorm(n, mean = 0, sd = 1)\nmean(n10s2) #deve se aproximar à média\n\n[1] 9.867616\n\nsd(n10s2) # deve se aproximar ao sd\n\n[1] 1.918911\n\n#obs: quanto maior o n, esperamos que média e sd se aproximem dos valores teóricos\nsort(n10s2) #ordenar o vetor n10s2 do menor valor para o maior\n\n  [1]  6.687291  6.711833  6.712995  6.734025  6.830608  6.869464  6.875737\n  [8]  7.080853  7.090713  7.211670  7.227722  7.358137  7.434354  7.476775\n [15]  7.645010  7.754499  7.755412  7.781758  7.835957  7.880751  8.108418\n [22]  8.194718  8.285085  8.294084  8.296559  8.469021  8.501805  8.566899\n [29]  8.619480  8.733052  8.761832  8.762677  8.765574  8.777484  8.823018\n [36]  8.870860  8.947351  9.013373  9.055807  9.203997  9.265759  9.335332\n [43]  9.435899  9.507145  9.587375  9.592484  9.638933  9.659189  9.743458\n [50]  9.844236 10.032401 10.035780 10.299468 10.344233 10.442811 10.455977\n [57] 10.480067 10.484196 10.486238 10.594383 10.624579 10.652871 10.658852\n [64] 10.675430 10.703043 10.814025 10.823355 10.835224 10.844763 10.922979\n [71] 10.925804 11.005784 11.108468 11.114490 11.117469 11.119923 11.374106\n [78] 11.374236 11.418167 11.425561 11.439434 11.500629 11.500805 11.561769\n [85] 11.650955 11.818365 11.844355 11.928979 11.966708 12.023514 12.265493\n [92] 12.357703 12.367548 12.504316 12.685664 12.950835 13.140960 14.291655\n [99] 14.592587 15.558127\n\nround(n10s2,2)# arredondar os valores para duas casas decimais para facilitar a visualização\n\n  [1] 10.82 15.56  7.84 13.14 10.48 12.69 12.95  8.19  8.78  9.51  8.50  8.30\n [13]  7.43 10.70 11.84  9.74  9.44  7.76  9.64  6.71  7.08 11.50 11.42  6.73\n [25] 14.59 10.59  8.76 10.93 11.50  9.59  9.20 10.66 10.48  7.21  8.57 10.84\n [37] 10.44  7.78 10.65 11.97 10.81  8.29 10.68 11.01  7.36  7.23 12.37 11.82\n [49] 10.04 10.30  9.01  9.84 11.37 11.12 10.49  8.29 12.02 10.03 11.11  6.88\n [61]  7.48  9.66  8.95  6.83  7.65  6.69  8.73 11.44  8.77 10.92 10.62 10.34\n [73]  8.62 11.43  6.87 14.29 12.50 11.65 11.93 12.27 12.36  9.06  8.47  8.11\n [85] 10.84 11.12 11.37  9.59 11.56  7.09  8.87  7.75 11.11  9.34  8.82  8.76\n [97]  7.88  6.71  9.27 10.46\n\n\nUtilizando outras distribuições: existem funções para gerar dados aleatórios a partir de outras distribuições de probabilidade, como a runif() para a distribuição uniforme e a rpois() para a distribuição de poisson.\n\nrunif(50, 10, 20) # uniforme n = 50, min =10, max = 20\n\n [1] 15.00583 12.07812 15.22252 13.28950 11.44656 15.70273 15.67932 13.82065\n [9] 11.78751 18.92995 16.09067 15.29339 11.88739 13.68023 11.53509 15.03474\n[17] 14.52821 18.36239 12.78802 14.47932 11.31796 15.26834 16.75945 19.38018\n[25] 18.65725 12.58448 11.88836 19.16082 12.09071 15.72135 17.72791 15.70626\n[33] 17.37896 18.87157 14.71124 19.04408 15.31759 16.31831 19.40848 12.47465\n[41] 13.08060 12.14161 10.09023 15.21227 17.92330 10.15260 11.14320 18.53364\n[49] 15.97156 18.66458\n\nrpois(50, 4) # poisson n = 50, lambda = 4\n\n [1]  6  5  2  2  4  1  4  8  6  4  6  4  5  3  0  3  8 11  4  2  3  4  3  6  4\n[26]  7  3  6  3  3  2  6  2  5  5  3  3  3  5 10  3  8  4  3  4  2  6  2  4  2\n\n\n\n\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de estatística em ecologia. Artmed.\n\n\nMello, M. P., & Peternelli, L. A. (2013). Conhecendo o R: uma visão mais que estatística. Editora UFV.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Distribuições de Probabilidade</span>"
    ]
  },
  {
    "objectID": "c07_TesteHip.html",
    "href": "c07_TesteHip.html",
    "title": "7  Testes de hipóteses",
    "section": "",
    "text": "7.1 Teste-t",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Testes de hipóteses</span>"
    ]
  },
  {
    "objectID": "c07_TesteHip.html#teste-t",
    "href": "c07_TesteHip.html#teste-t",
    "title": "7  Testes de hipóteses",
    "section": "",
    "text": "7.1.1 Teste-t para a comparação de duas amostras.\nVamos importar o conjunto de dados artropodes, que apresenta a abundância de artrópodes coletados com armadilhas pitfall em um fragmento florestal e na matriz do fragmento.\n\nlibrary(readxl)\nart &lt;- read_excel(\"dados_R.xlsx\", sheet = \"artropodes\") #importar dados\nstr(art)#estrutura do objeto\n\ntibble [16 × 2] (S3: tbl_df/tbl/data.frame)\n $ ambiente  : chr [1:16] \"fragmento\" \"fragmento\" \"fragmento\" \"fragmento\" ...\n $ abundancia: num [1:16] 30 56 46 45 65 74 44 71 95 102 ...\n\nart #visualizar o conjunto de dados\n\n# A tibble: 16 × 2\n   ambiente  abundancia\n   &lt;chr&gt;          &lt;dbl&gt;\n 1 fragmento         30\n 2 fragmento         56\n 3 fragmento         46\n 4 fragmento         45\n 5 fragmento         65\n 6 fragmento         74\n 7 fragmento         44\n 8 fragmento         71\n 9 matriz            95\n10 matriz           102\n11 matriz            86\n12 matriz           110\n13 matriz           128\n14 matriz            95\n15 matriz            87\n16 matriz            56\n\n\nNeste conjunto de dados temos uma variável categórica indicando o ambiente me uma variável contínua com a abundância de artrópodes em cada unidade amostral. Utilizamos o operador “~” para criar fórmulas. No exemplo, faremos um gráfico de boxplot comparando os ambientes (Figura 7.1) e um teste-t para comparar se há diferenças entre as médias de abundância artrópodes nos ambientes:\n\nboxplot(abundancia ~ ambiente, data = art) #boxplot: parece haver diferenças entre grupos\nt.test(abundancia ~ ambiente, data = art) #teste-t não pareado\n\n\n    Welch Two Sample t-test\n\ndata:  abundancia by ambiente\nt = -4.4927, df = 12.852, p-value = 0.0006224\nalternative hypothesis: true difference in means between group fragmento and group matriz is not equal to 0\n95 percent confidence interval:\n -60.73835 -21.26165\nsample estimates:\nmean in group fragmento    mean in group matriz \n                 53.875                  94.875 \n\n\n\n\n\n\n\n\nFigura 7.1: gráfico de boxplot comparando a abundância de artrópodes em dois ambientes.\n\n\n\n\n\npelo resultado, vemos que há diferença significativa entre a média da abundˆancia nos ambientes analizados: t(12.85) = -4,49; p = 0,0006.\n\n\n7.1.2 Teste-t pareado\nNo teste t pareado, as amostras são dependentes. Podemos utilizá-lo quando, por exemplo, aplicamos dois tratamentos diferentes em uma mesma amostra e queremos observar se houve diferença entre os tratamentos.\nNo exemplo, vamos comparar o tamanho corpóreo de galhadores e parasitas que ocorrem em uma mesma espécie de plantas hospedeiras. Para cada hospedeiro, temos o tamanho em milímetros do galhador e do parasita associado (Figura 7.2) e o teste-t não pareado abaixo indicam que as abundâncias são similares. No entanto, observamos nos valores do conjunto de dadosque para cada rio, o número de invertebrados na nascente é maior que o número na foz:\n\ngal &lt;- read_excel(\"dados_R.xlsx\", sheet = \"galhadores\") # importar os dados\ngal #observar os dados\n\n# A tibble: 13 × 3\n   hospedeiro galhador parasita\n   &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n 1 A              1.44     1.26\n 2 B              1.34     1.12\n 3 C              1.31     1.26\n 4 D              1.78     1.58\n 5 E              1.33     1.06\n 6 F              1.98     1.68\n 7 G              1.86     1.4 \n 8 H              1.8      1.39\n 9 I              1.87     1.82\n10 J              2.26     1.71\n11 K              2.15     1.37\n12 L              1.27     1.09\n13 M              1.86     1.35\n\nboxplot(gal[,2:3]) #observar se há diferença entre os grupos\nt.test(gal$galhador, gal$parasita) #teste-t não pareado\n\n\n    Welch Two Sample t-test\n\ndata:  gal$galhador and gal$parasita\nt = 2.7743, df = 21.885, p-value = 0.0111\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.08071393 0.55928607\nsample estimates:\nmean of x mean of y \n 1.711538  1.391538 \n\n\n\n\n\n\n\n\nFigura 7.2: gráfico de boxplot comparando galhadores e parasitas\n\n\n\n\n\nComo as amostras são pareadas, pois cada observação (cada linha) representa um hospedeiro e o galhador e parasita associado ao mesmo hospedeiro, podemos utilizar o teste-t pareado. Realizamos osso pois os galhadores e parasitas podem ter tamanhos diferentes simplesmente pelos hospedeiros apresentarem condições diferentes que causem diferenças nos tamanhos.\n\nt.test(gal$galhador, gal$parasita, paired = TRUE) # teste t pareado\n\n\n    Paired t-test\n\ndata:  gal$galhador and gal$parasita\nt = 5.4359, df = 12, p-value = 0.0001511\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n 0.1917387 0.4482613\nsample estimates:\nmean difference \n           0.32 \n\n\nNeste caso observamos uma diferença significativa entre as médias a uma significância de 5%: t(12) = 5,43, p = 0,00015.\nPodemos utilizar um boxplot ligando os pontos entre os valores para cada hospedeiro facilmente utilizando o ggpubr (Figura 7.3):\n\nlibrary(ggpubr)\n\nLoading required package: ggplot2\n\nggpaired(gal, cond1 = \"galhador\", cond2 = \"parasita\")\n\n\n\n\n\n\n\nFigura 7.3: gráfico de boxplot pareado comparando galhadores e parasitas,\n\n\n\n\n\nPela visualização dos dados, fica claro que os parasitas são menores que os galhadores associados a um mesmo hospedeiro.\n\n\n7.1.3 Teste-t para uma média\nO teste t para média de uma amostra pode ser utilizado para medir a probabilidade de a média da amostra em questão ter apresentado o valor observado \\(\\overline{x}\\) ou algo mais extremo, dada a média da população \\(\\mu_{0}\\). Sendo assim testamos as seguintes hipóteses:\n\n\\(H_{0}: \\overline{x} = \\mu_{0}\\)\n\n\n\\(H_{1}: \\overline{x} \\neq \\mu_{0}\\)\n\n\n\n7.1.4 Exemplo\nNa literatura observamos que indivíduos de uma determinada espécie apresentam 5 cm de comprimento. Ao realizar uma amostragem de 8 indivíduos desta espécie, obtemos os seguintes valores: 2.9, 2.6, 5.8, 3.7, 5.2, 0.1, 5.0 e 5.0. Para testar a afirmação encontrada na literatura, podemos elaborar as seguintes hipóteses:\n\n\\(H_{0}: \\overline{x} = 5\\)\n\n\n\\(H_{1}: \\overline{x} \\neq 5\\)\n\nTestaremos a hipótese nula com nível de significância \\(\\alpha = 0.05\\).\nPara obter o valor-t, utilizamos a seguinte fórmula:\n\n\\(t=\\frac{\\bar x-\\mu_{0}}{s/\\sqrt{n}}\\)\n\nAssim, podemos calcular:\n\nval &lt;-  c(2.9, 2.6, 5.8, 3.7, 5.2, 0.1, 5.0, 5.0)\nmean(val) # média\n\n[1] 3.7875\n\nsd(val) # desvio padrão\n\n[1] 1.881821\n\nt.val = (mean(val) - 5) / (sd(val)/sqrt(length(val)))\nt.val #valor-t observado\n\n[1] -1.82242\n\n\nCom os cálculos acima, encontramos o valor-t observado. Precisamos saber se este valor é maior ou igual do que o valor-t limite com significância \\(\\alpha = 0.05\\). Para isso temos que saber os graus de liberdade, que para este teste é calculado como \\(gl = n - 1 = 7\\).\nPodemos discutir isso olhando uma tabela da distribuição t (http://www.ttable.org), ou utilizando a função para quantis da distribuição t qt(). Como a significância é de 5% e o teste é bicaudal, utilizamos o valor de 2.5% para descobrir o valor t alvo:\n\nqt(0.025, df = 7) # 0.025 = significância; df = graus de liberdade \n\n[1] -2.364624\n\nqt(0.975, df = 7)# ou qt(0.025, df = 7, lower.tail = F) - valor para a outra cauda\n\n[1] 2.364624\n\n\nComo o valor-t obtido não é maior do que o valor-t alvo, falhamos em rejeitar a hipótese nula, assim assumimos que não há diferenças significativas entre a média das observações e a média populacional.\nO valor - p para o valor de t obtido pode ser calculado com:\n\npt(t.val, df = 7, lower.tail = T)*2\n\n[1] 0.1111736\n\n\nO teste realizado anteriormente pode ser reproduzido utilizando a função t.test:\n\nt.test(val, # valores\n       mu = 5, # média da população\n       alternative = \"two.sided\") # teste bicaudal\n\n\n    One Sample t-test\n\ndata:  val\nt = -1.8224, df = 7, p-value = 0.1112\nalternative hypothesis: true mean is not equal to 5\n95 percent confidence interval:\n 2.214258 5.360742\nsample estimates:\nmean of x \n   3.7875 \n\n\nNeste caso a média da amostra (3.7875) não foi significativamente diferente (p &gt; 0.05) da média da população (\\(\\mu\\) = 5): t(7) = -1.8224, p = 0.1112\n\n\n7.1.5 Teste unilateral vs teste bilateral\nO teste t pode ser usado para testar se o valor difere da média (teste bilateral), ou se ele é maior (ou menor) que esta média. Neste caso dizemos que este teste é unilateral (ou one-sided). Se testarmos a hipótese alternativa de que a média de uma amostra é maior que a média da população, elaboramos as seguintes hipóteses:\n\n\\(H_{0}: \\overline{x} \\leq \\mu_{0}\\)\n\n\n\\(H_{1}: \\overline{x} &gt; \\mu_{0}\\)\n\nNa Figura 7.4, podemos visualizar graficamente o que é a significância (\\(\\alpha\\)), o valor t alvo, o valor t observado e o valor p em um teste bilateral e unilateral:\n\n\n\n\n\n\nFigura 7.4: Representação gráfica da interpretação de um teste de hipótese (teste t) bilateral e unilateral\n\n\n\nVamos testar a hipótese de que a média da amostra (val) é MENOR que a média da população:\n\nt.test(val, mu = 5, alternative = \"less\")\n\n\n    One Sample t-test\n\ndata:  val\nt = -1.8224, df = 7, p-value = 0.05559\nalternative hypothesis: true mean is less than 5\n95 percent confidence interval:\n     -Inf 5.048009\nsample estimates:\nmean of x \n   3.7875 \n\n\nNeste caso, observamos que a média da amostra (3.7875) é menor do que a média da população (\\(\\mu\\) = 5), entretanto a diferença não é significativa (p &gt; 0.05): t(7) = -1.82, p = 0.056\n\n\n7.1.6 Premissas do teste-t\n\nDados coletados seguem uma escala contínua ou ordinal.\nDados amostrados aleatoriamente e amostra é representativa da população.\nOs dados apresentam distribuição normal.\nTamanho amostral suficientemente grande.\nHomogeneidade de variâncias.\n\n\n\n7.1.7 Avaliando as premissas do teste-t\nPodmeos aplicar diversosmétodos para avaliar se os dados não violam as premissas para o teste-t dentre as principais premissas temos:\n\n7.1.7.1 Normalidade\nO teste-t assume a premissa de normalidade dos resíduos. Isso pode ser avaliado de maneira visual utilizando gráficos quantil-quantil, que comparam os quantis observados com os quantis teóricos para a distribuição normal (Figura 7.5):\n\nqqnorm(residuals(lm(abundancia~ambiente, data = art))) #gráfico quantil-quantil\nqqline(residuals(lm(abundancia~ambiente, data = art))) #adicionar linha de tendência\n\n\n\n\n\n\n\nFigura 7.5: gráfico quantil-quantil para avaliar os pressupostos de normalidade.\n\n\n\n\n\nO observação de linearidade dos pontos em relação à reta sugere que os dados sejam normalmente distribuídos.\n\nObs: no próximo capítulo iremos ver em mais detalhes a utilização da função lm() para ajustar modelos lineares.\nExistem diferentes testes que podem ser utilizados para verificar normalidade. Um exemplo é o teste de Shapiro-Wilk:\n\nshapiro.test(residuals(lm(abundancia~ambiente, data = art)))\n\n\n    Shapiro-Wilk normality test\n\ndata:  residuals(lm(abundancia ~ ambiente, data = art))\nW = 0.97236, p-value = 0.8753\n\n\nO teste indicou que não há diferença significativa entre a distribuição dos dados e uma distribuição normal a uma significância de 5% (p &gt; 0.05).\nEmbora muitas vezes utilizados, os testes de normalidade tendem a ser sensíveis ao tamanho amostral, assim a análise visual e compreensão das distribuições teóricas que podem ter gerado os dados são mais indicados na hora de escolher o teste. Além disso, o teste-t se mostra robusto a desvios à normalidade (Tsagris & Pandis, 2021).\n\n\n7.1.7.2 Homogeneidade de variâncias\nO teste-t tradicional assume que as variâncias das amostras sejam iguais. Isso pode ser testado utilizando a função var.test:\n\nvar.test(abundancia ~ ambiente, data = art)\n\n\n    F test to compare two variances\n\ndata:  abundancia by ambiente\nF = 0.53976, num df = 7, denom df = 7, p-value = 0.4346\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1080626 2.6960678\nsample estimates:\nratio of variances \n         0.5397631 \n\n\nDe acordo com o teste, a razão entre as variâncias não difere significativamente de 1, ou seja, as variâncias não diferem significativamente.\nA função t.test pode ser utilizada para realizar o teste-t clássico (var.equal = TRUE) ou o teste-t de Welch, que ajusta os graus de liberdade quando as variâncias não são iguais, e deve ser usado nesse caso (var.equal = FALSE):\n\nt.test(abundancia ~ ambiente, data = art) #teste-t de Welch\n\n\n    Welch Two Sample t-test\n\ndata:  abundancia by ambiente\nt = -4.4927, df = 12.852, p-value = 0.0006224\nalternative hypothesis: true difference in means between group fragmento and group matriz is not equal to 0\n95 percent confidence interval:\n -60.73835 -21.26165\nsample estimates:\nmean in group fragmento    mean in group matriz \n                 53.875                  94.875 \n\nt.test(abundancia ~ ambiente, data = art, var.equal = TRUE) # teste-t tradicional\n\n\n    Two Sample t-test\n\ndata:  abundancia by ambiente\nt = -4.4927, df = 14, p-value = 0.0005062\nalternative hypothesis: true difference in means between group fragmento and group matriz is not equal to 0\n95 percent confidence interval:\n -60.57301 -21.42699\nsample estimates:\nmean in group fragmento    mean in group matriz \n                 53.875                  94.875 \n\n\n\n\n\n7.1.8 Testes não-paramétricos\nQuando os dados violam os pressupostos de normalidade, muitas vezes é sugerida a utilização de testes não paramétricos (entretanto veja Tsagris & Pandis, 2021). Um exemplo de teste não-paramétrico alternativo ao teste-t para duas amostras é o teste de Mann-Whitney:\n\nwilcox.test(abundancia ~ ambiente, data = art)\n\nWarning in wilcox.test.default(x = DATA[[1L]], y = DATA[[2L]], ...): cannot\ncompute exact p-value with ties\n\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  abundancia by ambiente\nW = 3.5, p-value = 0.00323\nalternative hypothesis: true location shift is not equal to 0\n\n\nNo caso de dados pareados, temos o teste de Wilcoxon, que também pode ser feito utilizando a função wilcox.test:\n\nwilcox.test(gal$galhador, gal$parasita, paired = TRUE)\n\nWarning in wilcox.test.default(gal$galhador, gal$parasita, paired = TRUE):\ncannot compute exact p-value with ties\n\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  gal$galhador and gal$parasita\nV = 91, p-value = 0.001651\nalternative hypothesis: true location shift is not equal to 0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Testes de hipóteses</span>"
    ]
  },
  {
    "objectID": "c07_TesteHip.html#teste-de-qui-quadrado",
    "href": "c07_TesteHip.html#teste-de-qui-quadrado",
    "title": "7  Testes de hipóteses",
    "section": "7.2 Teste de qui-quadrado",
    "text": "7.2 Teste de qui-quadrado\nO teste de qui-quadrado (\\(X^2\\)) é utilizado para comparar frequências observadas a frequências esperadas. O teste de qui-quadrado é considerado um teste não paramétrico, pois ele não depende da estimativa de parâmetros populacionais (média e variância).\n\n7.2.1 Teste de aderência/concordância\nNeste tipo de teste, observamos o quanto que um modelo probabilístico se adequa aos dados observados\nPodemos usar como exemplo o experimento de Mendel. O cruzamento entre heterozigotos de ervilhas lisas amarelas (YyRr x YyRr) teve o seguinte resultado. De acordo com as leis de Mendel, obteríamos as seguintes proporções esperadas para as ervilhas amarelas lisas: verdes lisas: amarelas rugosas: verdes rugosas - 9:3:3:1\n\nervilhas &lt;- data.frame(\n  Fenótipos = c(\"Amarela Lisa\", \"Verde lisa\", \"Amarela Rugosa\", \"Verde Rugosa\"),\n  Freq_obs = c(320, 110, 101, 35),\n  Prop_esp = c(9,3,3,1))\n\nervilhas\n\n       Fenótipos Freq_obs Prop_esp\n1   Amarela Lisa      320        9\n2     Verde lisa      110        3\n3 Amarela Rugosa      101        3\n4   Verde Rugosa       35        1\n\n\nPodemos calcular a frequência esperada a partir das proporções esperadas:\n\nFreq_esp &lt;- sum(ervilhas$Freq_obs)/sum(ervilhas$Prop_esp)*ervilhas$Prop_esp\nervilhas &lt;- data.frame(ervilhas, Freq_esp)\nervilhas\n\n       Fenótipos Freq_obs Prop_esp Freq_esp\n1   Amarela Lisa      320        9  318.375\n2     Verde lisa      110        3  106.125\n3 Amarela Rugosa      101        3  106.125\n4   Verde Rugosa       35        1   35.375\n\n\nO valor de qui-quadrado é calculado como:\n\n\\(X^2 = \\sum(\\frac{(observado-esperado)^2}{esperado})\\)\n\nSendo assim o valor de \\(X^2\\) pode ser calculado:\n\nsum(((ervilhas$Freq_obs - ervilhas$Freq_esp)^2)/ervilhas$Freq_esp)\n\n[1] 0.4012564\n\n\nPodemos calcular o \\(X^2\\) utilizando a função chisq.test():\n\nprop &lt;- ervilhas$Prop_esp/sum(ervilhas$Prop_esp) #cálculo da probabilidade esperada de obter cada valor : (9, 3, 3, 1)/16\nprop\n\n[1] 0.5625 0.1875 0.1875 0.0625\n\nchisq.test(ervilhas$Freq_obs, p = prop) # teste de qui-quadrado\n\n\n    Chi-squared test for given probabilities\n\ndata:  ervilhas$Freq_obs\nX-squared = 0.40126, df = 3, p-value = 0.94\n\n\nCom este teste, podemos observar que a frequência observada não é significativamente diferente da frequência observada.\n\n\n7.2.2 Teste de independência/contingência\nO teste de qui-quadrado pode ser usado para testar a independência entre duas variáveis medidas nas mesmas unidades de um experimento.\nExemplo: Ao realizar um experimento para testar se uma espécie de aranhas se abriga mais debaixo das pedras durante momentos de mais ou menos luz, foi analisado o tipo de ambiente que os animais foram encontrados (coberto ou aberto) durante o dia ou durante a noite. com isso, pode-se construir a seguinte tabela de contingência:\n\n\n\n\nCoberto\nAberto\n\n\n\n\nEscuro\n10\n29\n\n\nClaro\n33\n25\n\n\n\nPodemos criar esta tabela no R:\n\naranhas &lt;- data.frame(Coberto = c(10,33), Aberto =  c(29,25), row.names = c(\"Escuro\", \"Claro\"))\naranhas\n\n       Coberto Aberto\nEscuro      10     29\nClaro       33     25\n\n\nPara observar graficamente a quantidade de indivíduos em cada um dos conjuntos, podemos criar um gráfico em mosaico (Figura 7.6):\n\nmosaicplot(aranhas, main = NULL ,ylab = \"Ambiente\", xlab = \"Luminosidade\")\n\n\n\n\n\n\n\nFigura 7.6: gráfico em mosaico para dados de aranhas\n\n\n\n\n\nVamos realizar o teste de independência entre as duas variáveis:\n\nchisq.test(aranhas)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  aranhas\nX-squared = 8.0081, df = 1, p-value = 0.004657\n\n\nSendo assim, rejeitamos a hipótese de independência entre as variáveis. Ou seja, quando está escura, as aranhas preferem o ambiente aberto, e quando está claro, elas preferem o ambiente fechado.\n\n\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de estatística em ecologia. Artmed.\n\n\nMello, M. P., & Peternelli, L. A. (2013). Conhecendo o R: uma visão mais que estatística. Editora UFV.\n\n\nTonhasca Jr, A. (1991). The three \"capital sins\" of statistics used in biology. Ciência e Cultura, 43(6), 417422. message:%3C1527538750.417090.1562784042935@mail.yahoo.com%3E\n\n\nTsagris, M., & Pandis, N. (2021). Normality test: Is it really necessary? American Journal of Orthodontics and Dentofacial Orthopedics, 159(4), 548–549. https://doi.org/10.1016/j.ajodo.2021.01.003",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Testes de hipóteses</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html",
    "href": "c08_ModLinearReg.html",
    "title": "8  Modelos lineares e regressão",
    "section": "",
    "text": "8.1 Modelos lineares - regressão linear\nModelos são utilizados para se fornecer um resumo simples de um conjunto de dados (Wickham et al., 2023). Podemos usar modelos para explicar relações entre variáveis.\nPodemos descrever a relação entre x e y no exemplo abaixo (Figura 8.1):\nFigura 8.1: gráfico de dispersão mostrando a relação entre as variáveis x e y.\nNo exemplo acima, estamos tentando encontrar uma relação entre duas variáveis:\nAnálises de regressão são utilizadas quando queremos modelar a relação entre uma variável \\(Y\\) (variável resposta) e uma ou mais variáveis preditoras (Faraway, 2009).\nPodemos observar que há uma relação positiva entre as variáveis x e y. Sempre que há um incremento (aumento) em x, temos um aumento em y. O tipo de relação observada entre essas variáveis parece ser linear, ou seja, podemos explicar a relação entre x e y com uma função linear do tipo:\nNa função acima \\(B_0\\) representa o intercepto, ou o valor de \\(Y\\) para \\(X = 0\\). \\(B_1\\) representa a inclinação da reta, ou seja, sendo a taxa que \\(Y\\) irá aumentar em relação a \\(X\\). A variável \\(\\epsilon\\) representa o erro, ou seja, o quanto os pontos se afastam da reta (Figura 8.2).\nFigura 8.2: gráfico de dispersão mostrando a relação entre as variáveis x e y, incluindo a linha de tendência (vermelho) e resíduos (azul).\nNa figura acima, temos a reta que cruza o eixo x no valor 6.7 (\\(B_0\\)) e tem uma inclinação de 0.69 (\\(B_1\\)). Os traços em azul mostram a diferença entre os valores observados e os preditos pela reta (\\(\\epsilon\\)), que são chamados de resíduos.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#modelos-lineares---regressão-linear",
    "href": "c08_ModLinearReg.html#modelos-lineares---regressão-linear",
    "title": "8  Modelos lineares e regressão",
    "section": "",
    "text": "Variáveis preditoras (\\(x\\)): variáveis quantitativas, também chamadas de variáveis dependentes.\nVariável resposta (\\(y\\)): uma variável quantitativa a qual estamos interessados em descrever o efeito de x sobre ela. Também chamada de variável independente.\n\n\n\n\n\\(Y = B_0 + B_1.X +\\epsilon\\)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#regressão-linear-simples",
    "href": "c08_ModLinearReg.html#regressão-linear-simples",
    "title": "8  Modelos lineares e regressão",
    "section": "8.2 Regressão linear simples",
    "text": "8.2 Regressão linear simples\nVamos utilizar regressão linear para verificar se o comprimento do ovipositor de vespas está relacionado com o tamanho dos inflorescências de Ficus nas quais elas ovipõem.\nNo conjunto de dados oviposicao, temos medições de duas variáveis (2 colunas) de valores contínuos: o ovipositor em milímetros e o diâmetro da inflorescência em centímetros.\n\nlibrary(readxl)\novip &lt;- read_excel(\"dados_R.xlsx\", sheet = \"oviposicao\")\novip #visualizar os dados no console\n\n# A tibble: 22 × 2\n   tamanho ovipositor\n     &lt;dbl&gt;      &lt;dbl&gt;\n 1    0.36       1   \n 2    0.55       1.02\n 3    0.65       1.03\n 4    0.61       0.99\n 5    0.66       0.99\n 6    0.65       1.21\n 7    0.75       1.18\n 8    0.74       1.21\n 9    0.91       1.14\n10    0.75       1.11\n# ℹ 12 more rows\n\n\n\n#podemos usar: \nhead(ovip) #para ver as primeiras linhas\ncolnames(ovip) # para ver o nome das variáveis (nome das colunas)\ndim(ovip) #para observar o n. linhas e n. de colunas\n\nVamos observar em um gráfico de dispersão a relação entre as variáveis ovipositor e diametro (Figura 8.3).\n\nplot(ovipositor ~ tamanho, data = ovip)\n\n\n\n\n\n\n\nFigura 8.3: Relação o diâmetro da infrutescência e o comprimento do ovipositor do parasita associado.\n\n\n\n\n\nParece haver correlação entre as variáveis. Vamos fazer uma análise de correlação:\n\ncor.test(ovip$ovipositor, ovip$tamanho)\n\n\n    Pearson's product-moment correlation\n\ndata:  ovip$ovipositor and ovip$tamanho\nt = 10.629, df = 20, p-value = 1.124e-09\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8180054 0.9673984\nsample estimates:\n      cor \n0.9217296 \n\n\nHá uma correlação forte e positiva entre as variáveis (r = 0.92, p &lt; 10e-8), o que indica que as duas se relacionam positivamente.\nObs: o valor-p está em notação científica. Você pode transformar a notação:\n\nformat(1.124e-09, scientific = FALSE)\n\n[1] \"0.000000001124\"\n\n\nVamos realizar uma análise de regressão linear para testar se o tamanho do ovipositor da espécie de vespa associada está relacionado com o tamanho da inflorescência.\nA regressão é um tipo de modelo linear no qual testamos o efeito de variáveis contínuas sobre uma variável resposta que também é contínua. Este tipo de análise pode ser realizada utilizando a função lm() para ajustar um modelo linear (“linear model”).\nNeste caso, vamos considerar a variável ovipositorcomo variável resposta (no eixo y) e tamanho como variável preditora (no eixo x) em um modelo:\n\nmodelo &lt;- lm(ovipositor ~ tamanho, data= ovip)\nmodelo\n\n\nCall:\nlm(formula = ovipositor ~ tamanho, data = ovip)\n\nCoefficients:\n(Intercept)      tamanho  \n     0.7646       0.4868  \n\n\nCriando esse modelo, calculamos os seguintes coeficientes: o valor do intercepto (\\(B_0\\)) e o valor da inclinação da reta (\\(B_1\\)). Assim, podemos fazer o gráfico com a linha de regressão para o melhor modelo (Figura 8.4).\n\nmodelo$coefficients[1] #intercepto\n\n(Intercept) \n  0.7645629 \n\nmodelo$coefficients[2] #inclinação\n\n  tamanho \n0.4868174 \n\nplot(ovipositor ~ tamanho, data= ovip)\nabline(modelo$coefficients[1],modelo$coefficients[2], col = \"red\") #podemos utilizar os valoes coeficientes B0 e B1 calculados\n#ou também podemos utilizar o modelo diretamente\nabline(modelo, col = \"grey\", lty = 3)\n\n\n\n\n\n\n\nFigura 8.4: gráfico de dispersão com linha de tendência do modelo para a relação entre ovipositor da vespa e tamanho da inflorescência que ela ocupa.\n\n\n\n\n\n\n8.2.1 Hipóteses testadas\nNa regressão linear, ajustamos uma linha reta para explicar os valorses de \\(Y\\) em função de \\(X\\). Nossa hipótese é que há alguma relação entre as variáveis. Consequentemente estamos criando uma hipótese sobre a inclinação da reta. Assim temos:\n\n\\(H_0:Y_i=B_0+\\epsilon_i\\)\n\n\n\\(H_1:Y_i=B_0+B_1X_i+\\epsilon_i\\)\n\nTestamos a hipótese da inclinação da reta (\\(B_1\\)) ser ou não ser igual a 0.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#informações-da-regressão",
    "href": "c08_ModLinearReg.html#informações-da-regressão",
    "title": "8  Modelos lineares e regressão",
    "section": "8.3 Informações da regressão",
    "text": "8.3 Informações da regressão\nPodemos utilizar a função summary() para obter informações sobre a regressão:\n\nsummary(modelo)\n\n\nCall:\nlm(formula = ovipositor ~ tamanho, data = ovip)\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-0.131908 -0.047273 -0.005062  0.052697  0.129006 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  0.76456    0.04596   16.63 3.52e-13 ***\ntamanho      0.48682    0.04580   10.63 1.12e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.06976 on 20 degrees of freedom\nMultiple R-squared:  0.8496,    Adjusted R-squared:  0.8421 \nF-statistic:   113 on 1 and 20 DF,  p-value: 1.124e-09\n\n\nNeste resumo, temos as seguintes informações:\n\nCall: fórmula utilizada para a regressão.\nResiduals: estatística descritiva dos resíduos.\nCoefficients: valor dos coeficientes no caso intercept = \\(B_0\\) e tamanho = \\(B_1\\).\nOutros dados incluem o erro padrão dos resíduos, graus de liberdade, O \\(R^2\\) e \\(R^2\\) ajustado, e informações sobre o teste de hipótese do modelo linear (estatística f e valor-p).\n\nOutro valor que estamos interessados é o coeficiente de determinação (\\(R^2\\)). Um valor de \\(R^2\\) de 0.85 como observado indica que 85% da variação de \\(y\\) é explicada por \\(x\\). Assim, é uma medida de o quanto o modelo explica nossos dados e a parte da variação que não é explicada.\nQual é o tamanho de ovipositor previsto quando otamanho da inflorescência é 1,5 cm? Podemo calcualr utilizando a equação \\(Y = B_0+B_1x\\), sendo que \\(Y=0,76+0,49\\cdot1,5=1,495\\). Isso pede ser calculado utilizando a função predict:\n\npredict(modelo, data.frame(tamanho = 1.5))\n\n       1 \n1.494789 \n\n#múltiplos tamanhos\ntamanhos &lt;- data.frame(tamanho = c(0.7,0.9,1,1.5))\npredict(modelo, tamanhos)\n\n       1        2        3        4 \n1.105335 1.202699 1.251380 1.494789 \n\n\nObs: quando previmos os valores de \\(y\\) para o intervalo conhecido da variável \\(x\\), estamos fazendo uma interpolação. Caso desejássemos prever os resultados para um valor fora desse intervalo, fazemos uma extrapolação. A extrapolação exige uma abordagem mais cuidadosa devido à incerteza envolvida em prever além dos dados conhecidos (Gotelli & Ellison, 2016).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#diagnóstico-do-modelo",
    "href": "c08_ModLinearReg.html#diagnóstico-do-modelo",
    "title": "8  Modelos lineares e regressão",
    "section": "8.4 Diagnóstico do modelo",
    "text": "8.4 Diagnóstico do modelo\nA regressão linear, como todos os modelos lineares, tem as seguintes premissas:\n\nAs amostras são independentes.\nOs dados se encaixam em um modelo linear.\nOs resíduos estão homogeneamente distribuídos ao longo do eixo \\(x\\)\nOs resíduos apresentam distribuição normal.\n\nO diagnóstico de modelos lineares também pode ser realizado com a função plot() (Figura 8.5).\n\npar(mfrow = c(2,2)) #criar uma matriz de 4 janelas gráficas na mesma figura\nplot(modelo) #plotar os 4 gráficos de diagnóstico de modelos\n\n\n\n\n\n\n\nFigura 8.5: gráficos de diagnóstico do modelo.\n\n\n\n\n\nOs 4 gráficos que observamos são:\n\nGráfico de dispersão entre os resíduo e os valores ajustado, que permite verificar a distribuição dos dados ao longo do eixo \\(x\\). Neste gráfico, os pontos devem estar aleatoriamente distribuídos.\nGráfico quantil-quantil dos resíduos, que permite analisar a distribuição dos quantis observadoss com quantis teóricos de uma distribuição normal. Neste gráfico, os pontos devem estar próximos à linha.\nGráfico de dispersão da raiz quadrada dos resíduos padronizado pelos valores ajustados, que permite verificar a homogeneidade das variâncias. Neste gráfico, os pontos devem estar aleatoriamente distribuídos.\nDistância de Cook das observações, que permite avaliar se há valores extremos que podem influenciar a análise. Neste gráfico, os valores extremos ultrapassam a linha pontilhada (distâncias de Cook).\n\nAbaixo temos um exemplo de como os gráficos de diagnóstico do modelo ficariam no caso de haver violações na normalidade da distribuição dos resíduos (Figura 8.6). Para mais informações sobre a avaliação dos resíduos de regressão, consultar Jones et al. (2022).\n\n\n\n\n\n\n\n\nFigura 8.6: exeplo de diagnóstico de modelo quando há violação da normalidade dos resíduos.\n\n\n\n\n\nCaso estejamos interessados, podemos realizar um teste de hipóteses para confirmar se a distribuição dos resíduos é normal:\n\nshapiro.test(modelo$residuals)\n\n\n    Shapiro-Wilk normality test\n\ndata:  modelo$residuals\nW = 0.97832, p-value = 0.8878\n\n\nO teste de normalidade Shapiro-Wilk mostra que a distribuição dos resíduos observada não difere significativamente de uma distribuição normal a uma significância de 0.05 (5%).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#regressão-múltipla",
    "href": "c08_ModLinearReg.html#regressão-múltipla",
    "title": "8  Modelos lineares e regressão",
    "section": "8.5 Regressão múltipla",
    "text": "8.5 Regressão múltipla\nEm uma regressão linear múltipla analisamos a relação de uma variável resposta (\\(Y\\)) com mais de uma variável preditora (\\(X_1\\), \\(X_2\\) … \\(X_p\\)):\n\n\\(Y=B_0+B_1X_1+B_2X_2+...+B_iX_i+\\epsilon\\)\n\nPara estudar modelos lineares de regressão múltipla utilizaremos o conjunto de dados figos. Neste conjunto, temos dados de abundância de polinizadores, sementes e parasitas em inflorescências de figos. Neste sistema, as vespas polinizadoras (polinizadores), apesar de realizarem a polinização, ocupam algums flores para gerar sua prole. Além disso, vespas parasitas podem ocupar as flores, ocupando flores que se transformariam em sementes ou parasitar polinizadores. O número de flores e prole de vespas pode ser\n\nlibrary(readxl) #abrir pacote readxl\nfigos &lt;- read_excel(\"dados_R.xlsx\", sheet = \"figos\") #cria objeto chamado peixes com o conjunto de dados\nhead(figos)\n\n# A tibble: 6 × 4\n   diam sementes polinizadores parasitas\n  &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;\n1  1.58      220           117        14\n2  1.67      276            86        20\n3  1.6       180           150        20\n4  1.43      112            51         8\n5  1.49      172           108        24\n6  1.35      200           132         8\n\n\nVamos observar a relação entre as variáveis contínuas analisadas fazendo uma matriz de gráficos de dispersão (Figura 8.7).\n\npairs(figos)\n\n\n\n\n\n\n\nFigura 8.7: matriz de gráficos de dispersão para os dados de figos\n\n\n\n\n\nOlhando a figura, podemos ver que parece existir alguma relação entre as variáveis.\nPrimeiramente, vamos realizar uma regressão múltipla para determinar o efeito de cada uma das variáveis sobre a quantidade de sementes:\n\nmodelo1 &lt;- lm(sementes ~ diam + polinizadores + parasitas, data = figos)\nsummary(modelo1)\n\n\nCall:\nlm(formula = sementes ~ diam + polinizadores + parasitas, data = figos)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-73.122 -28.278   0.247  28.065  60.558 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)   -76.5226   115.4120  -0.663   0.5121  \ndiam          181.7844    80.1752   2.267   0.0303 *\npolinizadores  -0.0949     0.1539  -0.617   0.5418  \nparasitas       0.8165     0.6137   1.331   0.1927  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 36.01 on 32 degrees of freedom\nMultiple R-squared:  0.2599,    Adjusted R-squared:  0.1905 \nF-statistic: 3.745 on 3 and 32 DF,  p-value: 0.02058\n\n\nPodemos observar que o total de sementes parece estar relacionado com o diâmetro da inflorescência. As demais variáveis parecem não estar relacionadas com a produção de sementes na inflorescência. O diagnóstico do modelo indica que o modelo linear ajustou bem aos dados (Figura 8.8)\n\npar(mfrow = c(2,2))\nplot(modelo1)\n\n\n\n\n\n\n\nFigura 8.8: diagnóstico do modelo para dados de figos.\n\n\n\n\n\n\n8.5.1 Visualização do modelo\nO modelo pode ser visualizado com um gráfico de dispersão incluindo as variáveis de interesse. No exemplo anterior utilizamos as funções plot() e abline() para criar o gráfico. Entretanto, como temos aqui múltiplas variáveis, a alternativa mais prática é: (1) verificar as predições do modelo da variável resposta para os valores das variávieis preditoras que estamos interessados e (2) plotar um gráfico de dispersão incluindo a linha de tendência prevista pelo modelo. Isso pode ser feito facilmente com o pacote ggeffects (Figura 8.9).\nlibrary(ggeffects)#carregar o pacote\n\n#verificar os valores previstos pelo modelo com ggpredict.\n#A tabela mostra, para cada valor de área (em acres), a abundância de peixes prevista pelo modelo\nmodelo1.pred.area &lt;- ggpredict(modelo1, terms =  \"diam\")\nmodelo1.pred.area\n#plotar o gráfico incluindo também os dados observados\nplot(modelo1.pred.area, rawdata = TRUE) \n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n#criar gráfico do modelo para a variável \"área\", utilizando também a variável \"NO3\"\n\nmodelo1.pred.area.no3 &lt;- ggpredict(modelo1, terms =  c(\"diam\", \"parasitas\"))\nplot(modelo1.pred.area.no3, rawdata = TRUE)\n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n#neste caso, NO3 é incluído como fator. Podemos observar que nas maiores concentrações de NO3, a quantidade prevista de peixes é maior.\n\n\n\n\n\n# Predicted values of sementes\n\ndiam | Predicted |         95% CI\n---------------------------------\n1.20 |    135.63 |  90.48, 180.77\n1.40 |    171.98 | 155.67, 188.29\n1.60 |    208.34 | 183.29, 233.39\n1.80 |    244.70 | 188.81, 300.58\n\nAdjusted for:\n* polinizadores = 137.97\n*     parasitas =   8.69\n\n\n\n\n\n\n\n\n\n\n(a) preditor: diâmetro\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) preditor: diâmetro e parasitas\n\n\n\n\n\n\n\nFigura 8.9: gráfico de dispersão incluindo o ajuste do modelo para riqueza de figos e variáveis preditoras.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#comparação-de-modelos",
    "href": "c08_ModLinearReg.html#comparação-de-modelos",
    "title": "8  Modelos lineares e regressão",
    "section": "8.6 Comparação de modelos",
    "text": "8.6 Comparação de modelos\n\n8.6.1 Comparação de modelos com a função anova()\nPodemos comparar diferentes modelos aninhados com a função anova(). Vamos remover uma das variáveis menos significativas do modelo para ver se temos uma melhora significativa nele.\nPara isso, utilizaremos a função update() vamos atualizar o modelo1 de forma a remover a variável polinizadores:\n\nmodelo2 &lt;- lm(sementes ~ diam + parasitas, data = figos)\n#ou\nmodelo2 &lt;- update(modelo1, .~.-polinizadores)\n\nOs dois comandos acima fazem a mesma coisa. Na notação utilizando a função update(), atualizamos o modelo1, o sinal “. ~ .” indica que mantemos as variáveis que apresentava antes e “-polinizadores” indica a remoção de polinizadores do modelo.\n\nanova(modelo2, modelo1)\n\nAnalysis of Variance Table\n\nModel 1: sementes ~ diam + parasitas\nModel 2: sementes ~ diam + polinizadores + parasitas\n  Res.Df   RSS Df Sum of Sq      F Pr(&gt;F)\n1     33 41988                           \n2     32 41495  1    493.09 0.3803 0.5418\n\n\nPodemos ver que os modelos não são significativamente diferentes (F = 0,38; P = 0.54) desta forma, damos preferência ao modelo mais simples (com menos variáveis), ou seja, o modelo2.\nAtenção: para a comparação de modelos com ANOVA, os modelos devem ser aninhados, ou seja, as variáveis dependentes devem ser incuídas uma a uma.\n\n\n8.6.2 Comparando modelos por utilizando o Critério de Informação de Akaike (AIC)\nO critério de informação de Akaike é uma medida baseada na teoria da informação que pode ser usado para comparar modelos. Este critério mede o equilíbrio entre o acréscimo de variáveis em um modelo e o quanto esse acréscimo explica melhor o modelo. Utilizando este critério, podemos comparar os diversos modelos de forma a decidir qual explica melhor a variação da variável resposta. Este critério penaliza o acréscimo de variáveis pouco inflormativas em um modelo. Para mais informações sobre o AIC, consulte Aho et al. (2014).\nVamos criar outros modelos removendo variáveis pouco significativas:\n\nmodelo1 #já criado\n\n\nCall:\nlm(formula = sementes ~ diam + polinizadores + parasitas, data = figos)\n\nCoefficients:\n  (Intercept)           diam  polinizadores      parasitas  \n     -76.5226       181.7844        -0.0949         0.8165  \n\nmodelo2 #já criado\n\n\nCall:\nlm(formula = sementes ~ diam + parasitas, data = figos)\n\nCoefficients:\n(Intercept)         diam    parasitas  \n   -81.2701     175.4205       0.9298  \n\nmodelo3 &lt;- update(modelo2, .~.-parasitas)\nmodelo.nulo &lt;- lm(sementes ~ 1, data = figos) # modelo vazio\n\n# quanto menor o valor de Akaike, melhor o modelo\nAIC(modelo1, modelo2, modelo3, modelo.nulo)\n\n            df      AIC\nmodelo1      5 365.9563\nmodelo2      4 364.3816\nmodelo3      3 365.0810\nmodelo.nulo  2 370.7899\n\n#install.packages('wiqid') #se o pacote não foi instalado\nlibrary(wiqid)\n\nLoading required package: HDInterval\n\n\nLoading required package: mcmcOutput\n\nAICtable(AIC(modelo1, modelo2, modelo3, modelo.nulo)) # tabela do AIC\n\n            df     AIC Delta ModelLik ModelWt\nmodelo2      4 364.382 0.000    1.000   0.454\nmodelo3      3 365.081 0.699    0.705   0.320\nmodelo1      5 365.956 1.575    0.455   0.207\nmodelo.nulo  2 370.790 6.408    0.041   0.018\n\n\nNeste caso, modelo2 apresentou o menor AIC, entretanto os odelos 1,2 e 3 foram igualmente bons (\\(\\Delta AIC\\) &lt; 2), e melhores que o modelo nulo, n oqual a variável respsota foi testada em função de uma constante.\n\n\n8.6.3 Seleção de modelos com step()\nPodemos aselecionar automaticamente um modelo otimizado por AIC utilizando a função step, partindo do modelo mais complexo:\n\nmodelo.select &lt;- step(modelo1)\n\nStart:  AIC=261.79\nsementes ~ diam + polinizadores + parasitas\n\n                Df Sum of Sq   RSS    AIC\n- polinizadores  1     493.1 41988 260.22\n- parasitas      1    2295.6 43790 261.73\n&lt;none&gt;                       41495 261.79\n- diam           1    6666.2 48161 265.16\n\nStep:  AIC=260.22\nsementes ~ diam + parasitas\n\n            Df Sum of Sq   RSS    AIC\n&lt;none&gt;                   41988 260.22\n- parasitas  1    3269.4 45257 260.92\n- diam       1    6312.2 48300 263.26\n\nsummary(modelo.select)\n\n\nCall:\nlm(formula = sementes ~ diam + parasitas, data = figos)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-65.020 -31.119   1.822  29.634  63.681 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept) -81.2701   114.0685  -0.712   0.4812  \ndiam        175.4205    78.7581   2.227   0.0329 *\nparasitas     0.9298     0.5800   1.603   0.1185  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 35.67 on 33 degrees of freedom\nMultiple R-squared:  0.2511,    Adjusted R-squared:  0.2057 \nF-statistic: 5.532 on 2 and 33 DF,  p-value: 0.008477\n\n\nO algoritmo foi removendo as variáveis menos explicativas até chegar ao modelo que apresentou o melhor AIC. O modelo selecionado automaticamente a partir do modelo completo (modelo1). Vamos visualizar este modelo:\n\nsummary(modelo.select)\n\n\nCall:\nlm(formula = sementes ~ diam + parasitas, data = figos)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-65.020 -31.119   1.822  29.634  63.681 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept) -81.2701   114.0685  -0.712   0.4812  \ndiam        175.4205    78.7581   2.227   0.0329 *\nparasitas     0.9298     0.5800   1.603   0.1185  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 35.67 on 33 degrees of freedom\nMultiple R-squared:  0.2511,    Adjusted R-squared:  0.2057 \nF-statistic: 5.532 on 2 and 33 DF,  p-value: 0.008477\n\n\nO método de seleção automático utilizando step() deve se rutilizado com cautela. Este modelo selecionado automaticamente pode ser considerado um ponto de partida interessante, entretanto é necessário cautela e conhecimento do sistema estudado para avaliar pela inclusão ou remoção de variáveis. Para uma discussão sobre tais métodos, veja Magnusson (2003) .",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#interações-em-modelos",
    "href": "c08_ModLinearReg.html#interações-em-modelos",
    "title": "8  Modelos lineares e regressão",
    "section": "8.7 Interações em modelos",
    "text": "8.7 Interações em modelos\nInterações ocorrem quando o efeito de uma variável depende do valor de outra variável. Ao analisarmos o efeito de variáveis independentes sobre nossa variável dependente, existe a possibilidade de as variáveis independentes influenciarem uma as outras.\n\nmodelo.int &lt;-lm(peixes ~ area_acres * profundidade * NO3, data = peixes)\n\nsummary(modelo.int)\n\n\nCall:\nlm(formula = peixes ~ area_acres * profundidade * NO3, data = peixes)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-68.612 -18.874  -2.147   8.650 159.044 \n\nCoefficients:\n                              Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)                  3.980e+01  3.952e+01   1.007   0.3180  \narea_acres                  -3.801e-03  4.437e-03  -0.857   0.3950  \nprofundidade                -7.811e-01  5.914e-01  -1.321   0.1916  \nNO3                         -1.803e+01  1.218e+01  -1.481   0.1439  \narea_acres:profundidade      1.003e-04  6.453e-05   1.554   0.1253  \narea_acres:NO3               2.561e-03  1.461e-03   1.752   0.0848 .\nprofundidade:NO3             4.623e-01  1.920e-01   2.408   0.0191 *\narea_acres:profundidade:NO3 -4.260e-05  2.185e-05  -1.950   0.0559 .\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 40.37 on 60 degrees of freedom\nMultiple R-squared:  0.3472,    Adjusted R-squared:  0.2711 \nF-statistic: 4.559 on 7 and 60 DF,  p-value: 0.0003921\n\n\nA interação entre profundidade e NO3 parece significativa, o que indica que o efeito da variável profundidade é modulado pelo efeito da variável NO3 . Vamos ver se o modelo incluindo as interações é melhor que o modelo sem interações:\n\nanova(modelo.select, modelo.int)\n\nAnalysis of Variance Table\n\nModel 1: peixes ~ area_acres + profundidade + NO3\nModel 2: peixes ~ area_acres * profundidade * NO3\n  Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)\n1     64 108028                           \n2     60  97805  4     10222 1.5677 0.1946",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c08_ModLinearReg.html#multicolinearidade",
    "href": "c08_ModLinearReg.html#multicolinearidade",
    "title": "8  Modelos lineares e regressão",
    "section": "8.7 Multicolinearidade",
    "text": "8.7 Multicolinearidade\nUma das premissas dos modelos lineares é a independência dos preditores. Em uma regressão múltipla, quando temos duas ou mais variáveis preditoras correlacionadas, chamamos esse fenômeo de colinearidade. Quando dois ou mais preditores são correlacionados, podemos ter estimativas instáveis dos parâmetros no modelo.Vamos testar se há colinearidade esntre as variáveis analisadas.\nA possibilidade de colinearidade pode ser levantada quando há existência de uma alta correlação oentre variáveis:\n\ncor(figos)\n\n                    diam   sementes polinizadores  parasitas\ndiam          1.00000000  0.4390444    0.02717289  0.3280142\nsementes      0.43904445  1.0000000   -0.14976790  0.3721390\npolinizadores 0.02717289 -0.1497679    1.00000000 -0.2737100\nparasitas     0.32801421  0.3721390   -0.27371004  1.0000000\n\n\nO pacote performance pode ser utilizado para checar a existência de multicolinearidade, avaliando ofator de inflação da variância (variance inflation factor - VIF):\n\n#install.packages(\"performance\") #se o pacote ainda não tiver instalado\nlibrary(performance)\ncheck_collinearity(modelo1)\n\n# Check for Multicollinearity\n\nLow Correlation\n\n          Term  VIF   VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n          diam 1.14 [1.01, 2.66]         1.07      0.88     [0.38, 0.99]\n polinizadores 1.10 [1.00, 3.60]         1.05      0.91     [0.28, 1.00]\n     parasitas 1.23 [1.04, 2.28]         1.11      0.81     [0.44, 0.96]\n\n\nO VIF na faixa de 1 indica a inexistência de colinearidade, entre as variáveis, enquanto um valor entre 1 e 5 indicam colinearidade moderada. Um índice de 5 indica alta colinearidade entre variáveis.\n\n\n\n\nAho, K., Derryberry, D., & Peterson, T. (2014). Model selection for ecologists: the worldviews of AIC and BIC. Ecology, 95(3), 631–636. https://doi.org/10.1890/13-1452.1\n\n\nFaraway, J. J. (2009). Linear Models with R. Boca Raton.\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de estatística em ecologia. Artmed.\n\n\nJones, E., Harden, S., & Crawley, M. J. (2022). The R book (Third edition). Wiley.\n\n\nMagnusson, W. E. (2003). Estatistica Sem Matematica. Não definido.\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science: import, tidy, transform, visualize, and model data (2nd edition). O’Reilly Media, Inc.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modelos lineares e regressão</span>"
    ]
  },
  {
    "objectID": "c09_ModLinearANOVA.html",
    "href": "c09_ModLinearANOVA.html",
    "title": "9  Modelos lineares: ANOVA",
    "section": "",
    "text": "9.1 ANOVA de um fator\nVamos analisar o conjunto de dados figos_comp, que apresenta o diâmetro e a produção de sementes em figos de 3 espécies de figueiras.\nlibrary(readxl)\nfig_comp &lt;- read_excel(\"dados_R.xlsx\", sheet = \"figos_comp\") # importar os dados\nstr(fig_comp)\n\ntibble [60 × 3] (S3: tbl_df/tbl/data.frame)\n $ especie : chr [1:60] \"citrif\" \"citrif\" \"citrif\" \"citrif\" ...\n $ diametro: num [1:60] 1.58 1.67 1.6 1.43 1.49 1.35 1.42 1.4 1.51 1.53 ...\n $ sementes: num [1:60] 220 276 180 112 172 200 176 196 128 252 ...\nNo conjunto de dados, temos as variáveis contínuas diametro e sementes que analizaremos como variáveis resposta \\(y\\) e a variável categórica especie, que analisaremos como variável preditora \\(x\\).\nVamos comparar inicialente as espécies em relação à quantidade de sementes. Vamos visualizar graficamente os dados utilizando um boxplot (Figura 9.1).\nboxplot(sementes ~ especie, data = fig_comp)\n\n\n\n\n\n\n\nFigura 9.1: boxplot de sementes para três espécies de figos.\nAs medianas entre duas espécies Ficus citrifolia (citrif) e F. obtusifolia (obfol) são próximas, enquanto a espécie F. obtusiuscula (obus) parece apresentar menos sementes.\nVamos testar se há diferenças significativas entre os três grupos estudados:\nsem.lm &lt;- lm(sementes ~ especie, data = fig_comp)\n#outra maneira\nsem.aov &lt;- aov(sementes ~ especie, data = fig_comp)\nNeste passo, criamos um modelo linear testando a relação da variável categórica na variável contínua sementes. Podemos observar a tabela de ANOVA:\nanova(sem.lm) #ou summary(produt.aov)\n\nAnalysis of Variance Table\n\nResponse: sementes\n          Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nespecie    2 478631  239315  108.01 &lt; 2.2e-16 ***\nResiduals 57 126289    2216                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nA tabela de ANOVA mostra os graus de liberdade associados ao espécie e aos resíduos, as somas dos quadrados, os quadrados médios, o valor de F do teste de hipótese e o valor p. O valor de p nos indica que, considerando a significância de 0,05, rejeitamos \\(H_0\\) e dizemos que pelo menos uma das médias é diferente das demais.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modelos lineares: ANOVA</span>"
    ]
  },
  {
    "objectID": "c09_ModLinearANOVA.html#anova-de-um-fator",
    "href": "c09_ModLinearANOVA.html#anova-de-um-fator",
    "title": "9  Modelos lineares: ANOVA",
    "section": "",
    "text": "9.1.1 Análise do modelo\nPodemos analisar o modelo visualmente da mesma forma que fizemos com os modelos de regressão linear. Podemos observar se não há uma tendência de aumento dos resíduos ao longo do tratamento, e também se a distribuição dos resíduos se aproxima à distribuição normal ( Figura 9.2).\n\npar(mfrow = c(2,2))\nplot(sem.lm)\n\n\n\n\n\n\n\nFigura 9.2: diagnóstico do modelo da quantidade de sementes em três espécies.\n\n\n\n\n\nA primeira figura avalia se as variâncias são constantes e não deve haver um padrão entre os resíduos e os valores ajustados. No segundo, é testada a normalidade dos resíduos, e os pontos devem ser dipostos em uma linha reta na relação entre os resíduos padronizados e os quantis teóricos derivados da distribuição normal. O terceiro gráfico avalia o comportamento dos resíduos (para mais detalhes, ver Jones et al., 2022). Observamos que pode haver violação nos pressupostos dos modelos lineares, principalmente pela análise do gráfico quantil-quantil.\n\n\n9.1.2 Teste a posteriori\nO teste de ANOVA indicou a existência de diferenças em pelo menos um dos grupos. Para descobrir que grupos são diferentes, realizamos comparações par a par entre eles. Um dos testes utilizados para isso é o teste HSD de Tukey (Honest Significant Difference). Ele se assemelha a um teste t onde o erro do tipo I é corrigido para comparações múltiplas.\n\nTukeyHSD(aov(sem.lm)) #ou TukeyHSD(produt.aov)\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = sem.lm)\n\n$especie\n               diff         lwr        upr     p adj\nobfol-citrif   29.8   -6.019217   65.61922 0.1209402\nobus-citrif  -172.8 -208.619217 -136.98078 0.0000000\nobus-obfol   -202.6 -238.419217 -166.78078 0.0000000\n\n\nNos resultados é mostrada diferença das médias dos grupos par a par (diff), o intervalo de confiança entre as diferenças e o valor-p do teste estatístico. Neste caso observamos diferenças entre obfol e citrif e entre bus e obfol, mas não há diferenças entre obfol e citrif.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modelos lineares: ANOVA</span>"
    ]
  },
  {
    "objectID": "c09_ModLinearANOVA.html#anova-fatorial",
    "href": "c09_ModLinearANOVA.html#anova-fatorial",
    "title": "9  Modelos lineares: ANOVA",
    "section": "9.2 ANOVA fatorial",
    "text": "9.2 ANOVA fatorial\nA ANOVA de dois fatores pode ser utilizada quando temos duas variáveis categóricas preditoras.\nVamos utilizar os dados atividade. Neste conjunto temos dados simulados da alimentação e movimentação de duas espécies de insetos para machos ou fêmeas.\n\nativ &lt;- read_excel(\"dados_R.xlsx\", sheet = \"atividade\")\nhead(ativ)\n\n# A tibble: 6 × 3\n  tratamento sexo  movimento\n  &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt;\n1 A          M         12.4 \n2 A          M         10.0 \n3 A          M         10.0 \n4 A          M         14.7 \n5 A          M         12.0 \n6 A          M          8.77\n\n\nAo observar os boxplot ( Figura 9.3), podemos inferir que há diferença na quantidade de cálcio no sangue para grupos tratados com o hormônio e não tratados. O boxplot pode ser feito utilizando o pacote ggplot2:\n\nlibrary(ggplot2)\nggplot(ativ)+\n  geom_boxplot(aes(x = tratamento, y = movimento, fill = sexo))\n\n\n\n\n\n\n\nFigura 9.3: boxplot da movimentação em insetos machos e fêmeas que receberam 2 tratamentos.\n\n\n\n\n\nVamos criar o modelo utilizando a movimentaçãoo como variável resposta e tratamento e sexo como preditores, utilizando a função lm( ):\n\nmod.ativ &lt;- lm(movimento~ tratamento * sexo, data = ativ)\nanova(mod.ativ)\n\nAnalysis of Variance Table\n\nResponse: movimento\n                Df  Sum Sq Mean Sq F value   Pr(&gt;F)    \ntratamento       1  35.175  35.175  10.500 0.002011 ** \nsexo             1  84.966  84.966  25.364 5.26e-06 ***\ntratamento:sexo  1   2.204   2.204   0.658 0.420709    \nResiduals       56 187.595   3.350                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nObservamos um efeito significativo de tratamento sobre movimento. A variável sexo também explicou a variação na movimentação. A interação hormonio:sexo não foi significativa.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modelos lineares: ANOVA</span>"
    ]
  },
  {
    "objectID": "c09_ModLinearANOVA.html#ancova",
    "href": "c09_ModLinearANOVA.html#ancova",
    "title": "9  Modelos lineares: ANOVA",
    "section": "9.3 ANCOVA",
    "text": "9.3 ANCOVA\nA ANCOVA é uma extensão da ANOVA, onde incluímos fatores e variáveis contínuas (covariáveis) como variáveis preditoras. Assim, esse delineamento pode ser considerado como um híbrido entre ANOVA e regressão linear (gotelliPrincipiosEstatisticaEm2016?).\nPara exemplificar, vamos utilizar o conjunto de dados grilos, adaptado de (walker1962?), no qual foi estudado a canção de acasalamento de grilos. Neste conjunto, são apresentados os números de pulsos por segundo emitido por grilos machos das espécies Oecanthus exclamationis e O. niveus a diferentes temperaturas:\n\ngrilos &lt;- read_excel(\"dados_R.xlsx\", sheet = \"grilos\")\ngrilos\n\n# A tibble: 31 × 3\n   Temperatura Pulsos Especie        \n         &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          \n 1        20.8   67.9 O_exclamationis\n 2        20.8   65.1 O_exclamationis\n 3        24     77.3 O_exclamationis\n 4        24     78.7 O_exclamationis\n 5        24     79.4 O_exclamationis\n 6        24     80.4 O_exclamationis\n 7        26.2   85.8 O_exclamationis\n 8        26.2   86.6 O_exclamationis\n 9        26.2   87.5 O_exclamationis\n10        26.2   89.1 O_exclamationis\n# ℹ 21 more rows\n\n\nNeste conjunto, temos duas variáveis contínuas: o número de pulsos emitidos e a temperatura. Além disso temos uma variável categórica (espécie).\nVamos visualizar a relação entre o número de pulsos e temperatura, utilizando cores diferentes para espécies diferentes (Figura 9.4).\n\nggplot(grilos) +\n  geom_point(aes(x = Temperatura, y = Pulsos, col = Especie))+\n  theme_light()\n\n\n\n\n\n\n\nFigura 9.4: gráfico de dispersão relacionando a quantidade de pulsos e temperatura para duas espécies de grilos.\n\n\n\n\n\nAo visualizar os dados, parece haver uma clara relação positiva entre o número de pulsos emitidos e a temperatura. além disso, o número de pulsos emitidos parece diferir para cada espécie.\nVamos criar um modelo linear para ajustar o efeito das variáveis preditoras Temperatura e Especie na variável resposta Pulsos. Vamos considerar também a possibilidade de existir interação entre as duas variáveis preditoras:\n\ngrilos.lm &lt;- lm(Pulsos ~ Temperatura + Especie, data = grilos)\nsummary(grilos.lm)\n\n\nCall:\nlm(formula = Pulsos ~ Temperatura + Especie, data = grilos)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.0128 -1.1296 -0.3912  0.9650  3.7800 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)      -7.21091    2.55094  -2.827  0.00858 ** \nTemperatura       3.60275    0.09729  37.032  &lt; 2e-16 ***\nEspecieO_niveus -10.06529    0.73526 -13.689 6.27e-14 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.786 on 28 degrees of freedom\nMultiple R-squared:  0.9896,    Adjusted R-squared:  0.9888 \nF-statistic:  1331 on 2 and 28 DF,  p-value: &lt; 2.2e-16\n\n\nHá um claro efeito da Temperatura e da Especie na taxa de pulsos emitidas pelos grilos. O aumento de 1ºC na temperatura aumenta a taxa de pulsos em 3.6 segundo o modelo. Além disso, a espécie O. niveus apresenta em média 10 pulsos a menos do que a espécie O_exclamationis.\nPodemos verificar a tabela de ANOVA para o modelo:\n\nanova(grilos.lm)\n\nAnalysis of Variance Table\n\nResponse: Pulsos\n            Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nTemperatura  1 7894.8  7894.8  2474.0 &lt; 2.2e-16 ***\nEspecie      1  598.0   598.0   187.4 6.272e-14 ***\nResiduals   28   89.3     3.2                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAlém disso, podemos incluir a interação entre as variáveis preditoras, ou seja, se o efeito de uma das variáveis é modulado pelo efeito de outra:\n\n# Criar mdelo com interação\ngrilos.lm.int &lt;- lm(Pulsos ~ Temperatura * Especie, data = grilos)\n\n# comparar modelos\nanova(grilos.lm, grilos.lm.int)\n\nAnalysis of Variance Table\n\nModel 1: Pulsos ~ Temperatura + Especie\nModel 2: Pulsos ~ Temperatura * Especie\n  Res.Df    RSS Df Sum of Sq     F Pr(&gt;F)\n1     28 89.350                          \n2     27 85.074  1    4.2758 1.357 0.2542\n\n\nO acréscimo do parâmetro de interação não tornou o modelo significativamente melhor, deste modo, optamos pelo modelo mais simples que não considera a interação.\nPodemos utilizar a análise gráfica para diagnosticar o modelo (Figura 9.5)\n\npar(mfrow = c(2,2))\nplot(grilos.lm)\n\n\n\n\n\n\n\nFigura 9.5: diagnóstico do modelo grilos.lm.\n\n\n\n\n\nFinalmente, vamos criar um gráfico para observar os resultados, a partir do gráfico criado anteriormente (Figura 9.6).\n\nggplot(grilos, aes(x = Temperatura, y = Pulsos, col = Especie))+\n  geom_point()+\n  geom_smooth(method = \"lm\")+\n  theme_light()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigura 9.6: gráfico de dispersão entre o total de pulsos e temperatura para duas espécies de grilos incluindo ajuste do modelo linear.\n\n\n\n\n\nUm gráfico mais preciso mostrando a estimativa dos efeitos prevista pelo modelo pode ser feito com o pacote ggeffects (Figura 9.7).\n\ninstall.packages(\"ggeffects\") #caso o pacote não esteja instalado\n\n\nlibrary(ggeffects)\n\ngrilos.pred &lt;- ggpredict(grilos.lm, terms = c(\"Temperatura\",  \"Especie\"))\n\nplot(grilos.pred, rawdata = TRUE)\n\nData points may overlap. Use the `jitter` argument to add some amount of\n  random variation to the location of data points and avoid overplotting.\n\n\n\n\n\n\n\n\nFigura 9.7: gráfico de dispersão incluindo o ajuste do modelo utilizando o pacote ggeffects.\n\n\n\n\n\n\n\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de estatística em ecologia. Artmed.\n\n\nJones, E., Harden, S., & Crawley, M. J. (2022). The R book (Third edition). Wiley.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modelos lineares: ANOVA</span>"
    ]
  },
  {
    "objectID": "c11_Multivar.html",
    "href": "c11_Multivar.html",
    "title": "11  Estatística multivariada",
    "section": "",
    "text": "11.1 Métodos de ordenação\nAs técnicas de ordenação criam novas variáveis (chamadas eixos principais) por meio das quais as amostras recebem escores ou são organizadas. Desta forma, partimos com um conjunto maior de variáveis para um conjunto menor de variáveis que resumem os padrões mais importantes observados nos dados (Gotelli & Ellison, 2016).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatística multivariada</span>"
    ]
  },
  {
    "objectID": "c11_Multivar.html#métodos-de-ordenação",
    "href": "c11_Multivar.html#métodos-de-ordenação",
    "title": "11  Estatística multivariada",
    "section": "",
    "text": "11.1.1 Análise de Componentes Principais (PCA)\nA ideia da análise de componentes principais é encontrar uma combinação linear de diversas variáveis para capturar o máximo da variação possível (Crawley, 2013). Este método é utilizado para reduzir a dimensionalidade dos dados. A análise dos componentes principais é bem-sucedida quando temos fortes intercorrelações entre os dados originais (Gotelli & Ellison, 2016).\nNo conjunto de dados comunidades, temos a comunidade de vespas associadas a diferentes espécies de figueiras As três primeiras colunas representam as amostras, hospedeiros e áreas, enquanto as colunas 4 em diante representam as abundâncias de cada uma das espécies representadas por letras e números.\n\nlibrary(readxl)\ncomun &lt;- read_excel(\"dados_R.xlsx\", sheet = \"comunidades\")\ndim(comun) #dimensões do objeto: 25 linhas e 39 colunas\n\n[1] 25 39\n\ncolnames(comun) #nomes das colunas (variáveis)\n\n [1] \"amostra\"    \"hospedeiro\" \"local\"      \"Pe1\"        \"Pe2\"       \n [6] \"Pe7\"        \"Pe9\"        \"Ae1a\"       \"Ae1b\"       \"Ae3a\"      \n[11] \"Ae3b\"       \"Ae3c\"       \"Fi2\"        \"Fi6\"        \"Fi9\"       \n[16] \"An2\"        \"An3\"        \"Sy1\"        \"Sy2\"        \"Sy3\"       \n[21] \"Sy5\"        \"He1\"        \"He2\"        \"He7\"        \"Ic1\"       \n[26] \"Ic2\"        \"If3\"        \"If6\"        \"Ii7\"        \"Ic09\"      \n[31] \"Ic15\"       \"Ic17\"       \"Ic22\"       \"Ic26\"       \"Ic27\"      \n[36] \"Ph1\"        \"Ph2\"        \"Ph4\"        \"Na1\"       \n\n\nAs colunas 4 a 39 colunas apresentam as espécies que estamos interessados, e cada uma das linhas apresenta uma amostra.\nVamos extrair as colunas 4 a 39 e realizar a análise dos componentes principais. Utilizaremos a função prcomp(). Tendo em vista que a variância das abundâncias podem diferir entre as espécies, optamos incluir o argumento scale = TRUE. Assim, a variável será colocada em escala, com média igual a 0 e desvio padrão igual a 1.\n\npca.comun &lt;- prcomp(comun[,4:39], scale=TRUE) # objeto com a análise dos componentes principais.\nsummary(pca.comun)\n\nImportance of components:\n                          PC1    PC2    PC3     PC4     PC5     PC6     PC7\nStandard deviation     2.5400 2.3393 1.9132 1.68489 1.59477 1.48896 1.46515\nProportion of Variance 0.1792 0.1520 0.1017 0.07886 0.07065 0.06158 0.05963\nCumulative Proportion  0.1792 0.3312 0.4329 0.51174 0.58239 0.64398 0.70360\n                           PC8     PC9    PC10    PC11    PC12    PC13    PC14\nStandard deviation     1.29688 1.20065 1.15508 1.05916 0.92857 0.91999 0.87747\nProportion of Variance 0.04672 0.04004 0.03706 0.03116 0.02395 0.02351 0.02139\nCumulative Proportion  0.75032 0.79037 0.82743 0.85859 0.88254 0.90605 0.92744\n                          PC15    PC16   PC17    PC18    PC19   PC20    PC21\nStandard deviation     0.77723 0.75026 0.6893 0.58614 0.49796 0.4327 0.31782\nProportion of Variance 0.01678 0.01564 0.0132 0.00954 0.00689 0.0052 0.00281\nCumulative Proportion  0.94422 0.95986 0.9730 0.98260 0.98948 0.9947 0.99749\n                          PC22    PC23    PC24      PC25\nStandard deviation     0.21200 0.19738 0.08024 2.394e-16\nProportion of Variance 0.00125 0.00108 0.00018 0.000e+00\nCumulative Proportion  0.99874 0.99982 1.00000 1.000e+00\n\n\nForam criados 25 componentes principais, sendo que o primeiro explica 17,92% da variância nos dados. A linha Cumulative Proportion mostra a proporção cumulativa que é explicada por cada um dos componentes criados. Desta forma, os componentes PC1 a PC8 explicam 75% da variação total.\n\n11.1.1.1 Scree plots (gráficos de declive)\nNa etapa anterior, criamos um objeto de PCA, e observaremos como cada um dos componentes principais criados explicaram a variação dos dados. No exemplo o componente principal 1 (PC1) explica 16,7% da variância dos dados. Esses valores podem ser plotados em um gráfico:\n\nplot(pca.comun)\n\nPodemos melhorar a visualização com o pacote factoextra ( Figura 11.1). Caso não esteja instalado, utilizar o comando install.packages(\"factoextra\").\n\nlibrary(factoextra)\n\nLoading required package: ggplot2\n\n\nWelcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa\n\nfviz_eig(pca.comun, addlabels = TRUE)\n\n\n\n\n\n\n\nFigura 11.1: gráfico de declive (scree plot) para PCA dos dados pgfull.\n\n\n\n\n\nEsse gráfico mostra a proporção da variância explicada por cada um dos componentes principais.\n\n\n11.1.1.2 Biplots\nPodemos fazer gráficos mostrando os dois componentes principais (PC1 e PC2, ou até mesmo os demais componentes). Neste gráfico, as setas vermelhas representam cada uma das variáveis e os pontos (números) representam cada uma das observações (Figura 11.2).\n\npar(mar = c(4,2,2,2))\nbiplot(pca.comun)\n\n\n\n\n\n\n\nFigura 11.2: gráfico de biplot para PCA dos dados de comunidades\n\n\n\n\n\nQuanto mais longa é uma das setas, mais ela está relacionada com cada uma das variáveis. A visualização com a função biplot é um pouco difícil. então podemos utilizar o pacote factoextra para fazer a visualização somente das variáveis (Figura 11.3).\n\nfviz_pca_var(pca.comun, repel = TRUE)\n\n\n\n\n\n\n\nFigura 11.3: gráfico de biplot para PCA dos dados de comunidades no pacote factoextra.\n\n\n\n\n\nAgora vamos sofisticar o gráfico utilizando a função fviz_pca(), incluindo os argumentos col.ind para colorir os pontos pela variável “hospedeiro” e addEllipses para criar elipses para cada grupo de hospedeiros ( Figura 11.4).\n\nfviz_pca(pca.comun, \n         col.ind = comun$hospedeiro, # colorir observações pela variável \"hospedeiro\"\n         geom.ind = \"point\",# utilizar somente pontos para as observações, sem adicionar números\n         addEllipses = TRUE)# adicionar elipses para cada grupo\n\n\n\n\n\n\n\nFigura 11.4: análise dos componentes principais para os dados da comunidade\n\n\n\n\n\nPodemos observar que os pontos se agruparam por espécie hospedeira, que foi usada para definir o formato e cor dos pontos. As setas correspondem às espécies que mais ocorreram em cada hospedeiro, e espécies compartilhadas aperecem menos relacionadas com os grupos de pontos.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatística multivariada</span>"
    ]
  },
  {
    "objectID": "c11_Multivar.html#métodos-de-classificação",
    "href": "c11_Multivar.html#métodos-de-classificação",
    "title": "11  Estatística multivariada",
    "section": "11.2 Métodos de classificação",
    "text": "11.2 Métodos de classificação\nEnquanto os métodos de ordenação objetivamos separar amostras ao longo de gradientes ambientais ou eixos biológicos, o objeto da classificação é agrupar objetos similares em classes similares (gotelliPrincipiosEstatisticaEm2016?).\n\n11.2.1 Análise de agrupamento (Cluster analysis)\nA análise de agrupamento é um conjunto de técnicas que busca agrupar as amostras. As técnicas de agrupamento hierárquico podem ser utilizadas para mostrar quais espécies são mais similares entre si agrupando-as em dendrogramas.\nVamos realizar uma análise de agrupamento para observar se as as espécies de comunidades de vespas dem comun são agrupadas pelos hospedeiros. Primeiramente, iremos criar uma matriz de distâncias entre as nossas amostras, utilizando distâncias de Bray-Curtis.\n\n11.2.1.1 Organizar os dados\nPara facilitar a visualização posterior, precisamos criar um conjunto de dados do tipo data.frame nos quais os nomes das linhas correspondam às etiquetas que queremos utilizar. Cada nome de linhas deve ser único.\n\nCriar um data frame comun2, a partir do tibble comun em um com a função as.data.frame().\nCriar nomes para linhas para isso utilizaremos a função paste() para combinar:\n\nA coluna amostra, com o código da amostra;\nColuna hospedeiro;\nColuna local.\n\n\n\ncomun2 &lt;- as.data.frame(comun)\n\nhead(comun2)\n\n  amostra hospedeiro local  Pe1 Pe2 Pe7 Pe9 Ae1a Ae1b Ae3a Ae3b Ae3c Fi2 Fi6\n1     A01        cit   PEC  447   0   0   0    0    0    0    0    0   0   0\n2     A02        cit   PEC  308   0   0   0    0    0    0    0    0   0   0\n3     A03        cit   PEC 1106   0   0   0    5    0    0    0    0   1   0\n4     A04        cit   PEC  192   0   0   0    3    0    0    0    0   0   0\n5     A05        cit   PEC   81   0   0   0    2    0    0    0    0   0   0\n6     A06        cit    RP   93   0   0   0    0   19    0    0    0   0   0\n  Fi9 An2 An3 Sy1 Sy2 Sy3 Sy5 He1 He2 He7 Ic1 Ic2 If3 If6 Ii7 Ic09 Ic15 Ic17\n1   0   0   0   1   0   0   0   0   3   0 244 236  42   0   0    0    0    0\n2   0   0   0   0   0   0   0   0   0   0  55  42  60   0   0   64    0    0\n3   0   0   0   0   0   0   0   0   0   0  64  82 526   0  30    0    0    0\n4   0   0   0   2   0   2   0   1   2   0 185   0 217   2   1   44    0    0\n5   0   0   0  11   0   0   0   0  14   0   3 110   3   0   4    0    0    0\n6   0   0   0   5   0   0   0   0   2   0 163 165 149   0  13    2    0    0\n  Ic22 Ic26 Ic27 Ph1 Ph2 Ph4 Na1\n1    0    0    0   2   0   0 114\n2    0    9    0   2   3   0 355\n3    0    0    0   1   8   0 405\n4    0    0    0   5  48   0 184\n5    0    0    0  16  10   0 147\n6    0    0    0   8   4   0 138\n\nnome &lt;- paste(comun$amostra, comun$hospedeiro, comun$local, sep = \"_\")\n\nrownames(comun2) &lt;- nome\n\nhead(comun2)\n\n            amostra hospedeiro local  Pe1 Pe2 Pe7 Pe9 Ae1a Ae1b Ae3a Ae3b Ae3c\nA01_cit_PEC     A01        cit   PEC  447   0   0   0    0    0    0    0    0\nA02_cit_PEC     A02        cit   PEC  308   0   0   0    0    0    0    0    0\nA03_cit_PEC     A03        cit   PEC 1106   0   0   0    5    0    0    0    0\nA04_cit_PEC     A04        cit   PEC  192   0   0   0    3    0    0    0    0\nA05_cit_PEC     A05        cit   PEC   81   0   0   0    2    0    0    0    0\nA06_cit_RP      A06        cit    RP   93   0   0   0    0   19    0    0    0\n            Fi2 Fi6 Fi9 An2 An3 Sy1 Sy2 Sy3 Sy5 He1 He2 He7 Ic1 Ic2 If3 If6 Ii7\nA01_cit_PEC   0   0   0   0   0   1   0   0   0   0   3   0 244 236  42   0   0\nA02_cit_PEC   0   0   0   0   0   0   0   0   0   0   0   0  55  42  60   0   0\nA03_cit_PEC   1   0   0   0   0   0   0   0   0   0   0   0  64  82 526   0  30\nA04_cit_PEC   0   0   0   0   0   2   0   2   0   1   2   0 185   0 217   2   1\nA05_cit_PEC   0   0   0   0   0  11   0   0   0   0  14   0   3 110   3   0   4\nA06_cit_RP    0   0   0   0   0   5   0   0   0   0   2   0 163 165 149   0  13\n            Ic09 Ic15 Ic17 Ic22 Ic26 Ic27 Ph1 Ph2 Ph4 Na1\nA01_cit_PEC    0    0    0    0    0    0   2   0   0 114\nA02_cit_PEC   64    0    0    0    9    0   2   3   0 355\nA03_cit_PEC    0    0    0    0    0    0   1   8   0 405\nA04_cit_PEC   44    0    0    0    0    0   5  48   0 184\nA05_cit_PEC    0    0    0    0    0    0  16  10   0 147\nA06_cit_RP     2    0    0    0    0    0   8   4   0 138\n\n\nNesta etapa, criamos uma matriz de dados de comunidades, onde as linhas representam as amostras e as colunas representam as espécies.\nA partir desses dados, vamos:\n\nCalcular as distâncias entre as amostras utilizando o índice de Bray-Curtis, com a função vegdist(). Atenção: somente utilizar as colunas referentes às espécies, descartando as 3 primeiras colunas (amostra, hospedeiro e local).\nA partir da matriz de distâncias, realizar o agrupamento hierárquico pelo método de UPGMA (Unweighted Pair Group Method using Arithmetic averages), utilizando a função hclust(), com o argumento method = \"average\".\nvisualizar o agrupamento com a função plot() ( Figura 11.5).\n\n\nlibrary(vegan) # carregar o pacote vegan\n\nLoading required package: permute\n\n\nLoading required package: lattice\n\n\nThis is vegan 2.6-6.1\n\ncomun.dist &lt;- vegdist(comun2[,-(1:3)], method = \"bray\") # calcular distâncias\n\ncomun.clust &lt;- hclust(comun.dist, method = \"average\") # Agrupamento hierárquico (UPGMA)\n\nplot(comun.clust, cex = 1) # Plotar o agrupamento hierárquico.\n\n\n\n\n\n\n\nFigura 11.5: dendrograma obtido por UPGMA agrupando as observações de pinguins selecionadas\n\n\n\n\n\nNo agrupamento, podemos ver 3 grupos principais, representando os 3 hospedeiros (cit, exi e cro). As amostras de cro são mais similares às de exi do que às de cit.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatística multivariada</span>"
    ]
  },
  {
    "objectID": "c11_Multivar.html#testes-de-hipótese-em-análise-multivariada",
    "href": "c11_Multivar.html#testes-de-hipótese-em-análise-multivariada",
    "title": "11  Estatística multivariada",
    "section": "11.3 Testes de hipótese em análise multivariada",
    "text": "11.3 Testes de hipótese em análise multivariada\nPodemos utilisar métodos de análise de variância permutacional (PERMANOVA) sobre a matriz de distância para observar o efeito de um fator sobre as distâncias entre as amostras. No exemplo do conjunto de dados de comunidades, vamos testar a hipótese de que a diferença entre as comunidades dse deve à diferenças entre hospedeiros e entre localidades. A PERMANOVA pode ser realizada com a função adonis2() do pacote vegan:\n\nlibrary(vegan)\n\ncomun.permanova &lt;- adonis2(comun[,-(1:3)] ~ hospedeiro + local, data = comun, method = \"bray\", permutations = 1000)\n\ncomun.permanova\n\nPermutation test for adonis under reduced model\nTerms added sequentially (first to last)\nPermutation: free\nNumber of permutations: 1000\n\nadonis2(formula = comun[, -(1:3)] ~ hospedeiro + local, data = comun, permutations = 1000, method = \"bray\")\n           Df SumOfSqs      R2       F   Pr(&gt;F)    \nhospedeiro  2   5.5717 0.62516 19.0545 0.000999 ***\nlocal       1   0.2705 0.03035  1.8498 0.101898    \nResidual   21   3.0703 0.34450                     \nTotal      24   8.9125 1.00000                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nPodemos observar que há uma clara relação entre o hospedeiro e a composição da comunidade, entretanto a relação com o local parece ser apenas marginal. É preciso interpretar com cautela esses resultados quando os dados não são balanceados, ou seja, quando não há número próximo de réplicas por grupos. No caso que apresentamos, poderíamos remover o as linhas da espécie cro, mantendo somente as espécies cit e exi, que apresentam cada uma 10 observações com 5 observações por localidade, resultando em um experimento balanceados\n\n\n\n\nCrawley, M. J. (2013). The R book (Second edition). Wiley.\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de estatística em ecologia. Artmed.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatística multivariada</span>"
    ]
  },
  {
    "objectID": "c12_Tidyverse.html",
    "href": "c12_Tidyverse.html",
    "title": "12  Introdução ao Tidyverse",
    "section": "",
    "text": "12.1 Instalação e importação de dados de exemplo.\nPara este tópico, utilizaremos alguns pacotes do tidyverse e o conjunto de dados dos pinguins. Os pacotes do tidyverse podem ser instalados todos juntos utilizando install.packages(\"tidyverse) e depois carregados:\n#abrir o conjunto de pacotes do tidyverse\nlibrary(tidyverse)\n\n#importar dados de pinguins\nlibrary(readxl)\npinguins &lt;- read_excel(\"dados_R.xlsx\", sheet = \"pinguins\")",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introdução ao Tidyverse</span>"
    ]
  },
  {
    "objectID": "c12_Tidyverse.html#utilizando-pipes",
    "href": "c12_Tidyverse.html#utilizando-pipes",
    "title": "12  Introdução ao Tidyverse",
    "section": "12.2 Utilizando pipes",
    "text": "12.2 Utilizando pipes\nOs pipes são ferramentas que permitem criar sequências de operações, em vez de aninhar funções uma dentro da outra. Eles permitem que se realize várias modificações de um objeto sem a necessidade de se criar objetos intermediários, o que pode facilitar bastante o fluxo de análise. O operador pipe é representado por %&gt;% no tidyverse. Há também o pipe nativo do R |&gt;, que funciona de forma muito próxima ao pipe do tidyverse e em geral podem ser usados da mesma forma. O pipe pode se radicionado no Rstudio com o atalho Ctrl + Shift + M.\n\n#média de peso\nmean(pinguins$peso)\n\n[1] 4207.057\n\n#média de peso com o pipe do tidyverse\npinguins$peso %&gt;%  \n  mean()\n\n[1] 4207.057\n\n#média de peso com o pipe nativo do R\npinguins$peso |&gt;   \n  mean()\n\n[1] 4207.057",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introdução ao Tidyverse</span>"
    ]
  },
  {
    "objectID": "c12_Tidyverse.html#o-pacote-dplyr",
    "href": "c12_Tidyverse.html#o-pacote-dplyr",
    "title": "12  Introdução ao Tidyverse",
    "section": "12.3 O pacote dplyr",
    "text": "12.3 O pacote dplyr\nO pacote dplyr apresenta funções para manipular conjuntos de dados, como filtrar, reordenar ou selecionar colunas. Vamos utilizar no exemplo, a função summarise() e group_by() para calcular estatísticas descritivas para as espécies de pinguins\n\nsummarise() utilizada para resumir os dados de coluna em um único valor\ngroup_by() utilizada para agrupar variáveis por um determinado fator.\n\nNo exemplo (1) calculamos a média do peso dos pinguins. Utilizamos summarise(peso_média = mean(peso)) para criar uma variável peso_média representando a média de peso_g dos pinguins; (2) utilizamos a função group_by() para agrupar os pesos por espécie e depois caculamos a média e o desvio padrão para cada espécie utilizando summarise(), e (3) calculamos a média e desvio padrão para cada espécie e sexo.\n\n#peso médio dos pinguins\npinguins %&gt;% \n  summarise(peso_média = mean(peso))\n\n# A tibble: 1 × 1\n  peso_média\n       &lt;dbl&gt;\n1      4207.\n\n#média e desvio padrão de peso agrupada para cada espécie\npinguins %&gt;% \n  group_by(especie) %&gt;% \n  summarise(peso_média = mean(peso), peso_sd = sd(peso))\n\n# A tibble: 3 × 3\n  especie  peso_média peso_sd\n  &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;\n1 Adelia        3706.    459.\n2 Barbicha      3733.    384.\n3 Gentoo        5092.    501.\n\n#média e desvio padrão de peso agrupada para cada espécie e sexo\npinguins %&gt;%\n  group_by(especie, sexo) %&gt;%\n  summarise(peso_média = mean(peso), peso_sd = sd(peso))\n\n`summarise()` has grouped output by 'especie'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 6 × 4\n# Groups:   especie [3]\n  especie  sexo  peso_média peso_sd\n  &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n1 Adelia   Femea      3369.    269.\n2 Adelia   Macho      4043.    347.\n3 Barbicha Femea      3527.    285.\n4 Barbicha Macho      3939.    362.\n5 Gentoo   Femea      4680.    282.\n6 Gentoo   Macho      5485.    313.\n\n\nVamos utilizar a função select() para selecionar variáveis de interesse. Depois utilizaremos a função mutate() para transformar variáveis ou realizar cálculos para calcular a razão entre a coluna do peso e a coluna do comprimento da nadadeira.\n\npinguins %&gt;%\n  select(especie, sexo, peso, nadadeira) %&gt;%\n  mutate(peso.nadadeira = peso/nadadeira)\n\n# A tibble: 333 × 5\n   especie sexo   peso nadadeira peso.nadadeira\n   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;\n 1 Adelia  Macho  3750       181           20.7\n 2 Adelia  Femea  3800       186           20.4\n 3 Adelia  Femea  3250       195           16.7\n 4 Adelia  Femea  3450       193           17.9\n 5 Adelia  Macho  3650       190           19.2\n 6 Adelia  Femea  3625       181           20.0\n 7 Adelia  Macho  4675       195           24.0\n 8 Adelia  Femea  3200       182           17.6\n 9 Adelia  Macho  3800       191           19.9\n10 Adelia  Macho  4400       198           22.2\n# ℹ 323 more rows\n\n\nCaso eu tenha interesse em criar uma coluna transformado o peso em gramas em peso em kg (1 kg = 1000 g).\n\npinguins %&gt;%\n  select(especie, sexo, peso) %&gt;%\n  mutate(peso_kg = peso/1000)\n\nUtilizando a função filter() para filtrar (selecionar) somente pinguins fêmeas da ilha biscoe, depois utilizar o ggplot2 para criar um gráfico boxplot comparando as espécies. Para mais informações sobre gráficos).\n\nlibrary(ggplot2)\n\npinguins %&gt;%\n  filter(sexo == \"Femea\" & ilha == \"Biscoe\") %&gt;%\n  ggplot(aes(y = peso, x = especie))+\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n12.3.1 Formato longo e curto: pivot_longer() e pivot_wider()\nEssas funções podem ser usadas para colocar os dados em formato longo (menos colunas e mais linhas) ou largo (menos linhas e mais colunas).\n\n  pinguins %&gt;%\n  select(especie, sexo, peso, nadadeira) %&gt;%\n  pivot_longer(peso: nadadeira, names_to = \"variável\", values_to = \"valor\")\n\n# A tibble: 666 × 4\n   especie sexo  variável  valor\n   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Adelia  Macho peso       3750\n 2 Adelia  Macho nadadeira   181\n 3 Adelia  Femea peso       3800\n 4 Adelia  Femea nadadeira   186\n 5 Adelia  Femea peso       3250\n 6 Adelia  Femea nadadeira   195\n 7 Adelia  Femea peso       3450\n 8 Adelia  Femea nadadeira   193\n 9 Adelia  Macho peso       3650\n10 Adelia  Macho nadadeira   190\n# ℹ 656 more rows\n\n\nVamos fazer o movimento inverso com os dados de pinguins, transformando do formato longo para o largo. Para fazer isso, vamos criar um objeto com os dados longos. Para que possamos reverter do formato longo para o largo, precisamos de um valor único para identificar cada linha, então criaremos uma coluna com a identificação da linha (id) com valores de 1 a 333 (o número de linhas do conjunto de dados).\n\npinguins_longo &lt;- \npinguins %&gt;%\n  select(especie, sexo, peso, nadadeira) %&gt;%\n  mutate(id = 1:nrow(pinguins)) %&gt;%\n  pivot_longer(peso:nadadeira, names_to = \"variável\", values_to = \"valor\")\n\nhead(pinguins_longo) #ver as primeiras linhas\n\nAgora vamos transformar do formato longo para o formato largo:\n\npinguins_longo %&gt;%\n  pivot_wider(names_from = \"variável\", values_from = \"valor\")\n\n# A tibble: 333 × 5\n   especie sexo     id  peso nadadeira\n   &lt;chr&gt;   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Adelia  Macho     1  3750       181\n 2 Adelia  Femea     2  3800       186\n 3 Adelia  Femea     3  3250       195\n 4 Adelia  Femea     4  3450       193\n 5 Adelia  Macho     5  3650       190\n 6 Adelia  Femea     6  3625       181\n 7 Adelia  Macho     7  4675       195\n 8 Adelia  Femea     8  3200       182\n 9 Adelia  Macho     9  3800       191\n10 Adelia  Macho    10  4400       198\n# ℹ 323 more rows",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introdução ao Tidyverse</span>"
    ]
  },
  {
    "objectID": "c12_Tidyverse.html#dados-relacionais",
    "href": "c12_Tidyverse.html#dados-relacionais",
    "title": "12  Introdução ao Tidyverse",
    "section": "12.4 Dados relacionais",
    "text": "12.4 Dados relacionais\nPodemos buscar informações de uma tabela em outra tabela, caso tenhamos uma coluna chave que relaciona as duas.\nNos conjuntos de dados, a aba amostras apresenta os dados de amostragem como data e local de coleta, enquanto a planilha id apresenta dados da identificação das espécies coletadas.\n\nlibrary(readxl)\namostras &lt;- read_excel(\"dados_R.xlsx\", sheet = \"amostras\")\namostras\n\n# A tibble: 29 × 6\n   Amostra   Dia   Mês   Ano Pais   Prov_Est \n   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    \n 1 AM001       1     3  2019 Brasil Goiás    \n 2 AM002       1     3  2019 Brasil Goiás    \n 3 AM003       1     3  2019 Brasil Goiás    \n 4 AM004       6     4  2019 Brasil Goiás    \n 5 AM005       6     4  2019 Brasil Goiás    \n 6 AM006      12     8  2019 Brasil Goiás    \n 7 AM007      12     8  2019 Brasil Goiás    \n 8 AM008      12     8  2019 Brasil Goiás    \n 9 AM009      12     8  2019 Brasil Goiás    \n10 AM010      12     8  2019 Brasil São Paulo\n# ℹ 19 more rows\n\nid &lt;- read_excel(\"dados_R.xlsx\", sheet = \"id\")\nid\n\n# A tibble: 24 × 3\n   Amostra Familia    Especie               \n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;                 \n 1 AM001   Eupelmidae Lutnes testaceus      \n 2 AM001   Mymaridae  Gonatocerus litoralis \n 3 AM001   Eupelmidae Merostenus melinus    \n 4 AM005   Mymaridae  Neomymar mirabilicorne\n 5 AM005   Mymaridae  Neomymar mirabilicorne\n 6 AM005   Mymaridae  Neomymar soror        \n 7 AM005   Mymaridae  Neomymar soror        \n 8 AM010   Encyrtidae Copidosoma floridanum \n 9 AM024   Eupelmidae Lutnes testaceus      \n10 AM024   Mymaridae  Gonatocerus litoralis \n# ℹ 14 more rows\n\n\nAs tabelas apresentam uma coluna chave (key) chamada Amostra, que relaciona uma com a outra. Com isso, podemos preencher o dado da tabela da identificação dos insetos com as informações de coleta:\n\nmatch(id$Amostra, amostras$Amostra) # encontra a correspondência para cada elemento de id em amostra.\n\n [1]  1  1  1  5  5  5  5 10 24 24 24 24 24 24  5  6  7  8  9  9 12 23 24 25\n\n\n\n12.4.1 Trabalhando com dados relacionais e filtros no tidyverse\nPacotes como o dplyr apresentam diversas funções para manipular conjuntos de dados. Vamos juntar as tabelas id e amostras pela coluna Amostra, e depois filtrar somente as amostras de Goiás e pertencentes à Família Agaonidae:\n\nlibrary(dplyr)\n\nid %&gt;%\n  left_join(amostras, by = \"Amostra\") %&gt;%\n  filter(Prov_Est == \"Goiás\" & Familia == \"Agaonidae\")\n\n# A tibble: 5 × 8\n  Amostra Familia   Especie                 Dia   Mês   Ano Pais   Prov_Est\n  &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   \n1 AM005   Agaonidae Pegoscapus aerumnosus     6     4  2019 Brasil Goiás   \n2 AM006   Agaonidae Pegoscapus aerumnosus    12     8  2019 Brasil Goiás   \n3 AM007   Agaonidae Pegoscapus sp.4          12     8  2019 Brasil Goiás   \n4 AM008   Agaonidae Pegoscapus sp.4          12     8  2019 Brasil Goiás   \n5 AM009   Agaonidae Pegoscapus sp.4          12     8  2019 Brasil Goiás   \n\n\n\n\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science: import, tidy, transform, visualize, and model data (2nd edition). O’Reilly Media, Inc.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introdução ao Tidyverse</span>"
    ]
  },
  {
    "objectID": "c13_Progr.html",
    "href": "c13_Progr.html",
    "title": "13  Programação, strings e dados relacionais",
    "section": "",
    "text": "13.1 Gerando dados aleatórios\nO R pode ser utilizado para gerar dados (pseudo) aleatórios. Essas funções são interessantes para realizar simulações de análises\nVamos gerar 100 números aleatórios a partir da distribuição normal, com média 10 e desvio padrão 2\nnorm10d2 &lt;- rnorm(100, mean = 10, sd = 2)\nmean(norm10d2) # média\n\n[1] 10.04513\n\nsd(norm10d2) # desvio padrão\n\n[1] 2.056923\nComo são valores aleatórios, a cada vez que forem gerados teremos um valor diferentes. Valores exatamente iguais para reproduzir os resultados podem ser conseguidos executando a função set.seed(x), sendo x un valor qualquer, antes de gerar os dados aleatórios.\nPode-se gerar valores a partir de outras distribuições:\nrpois(10, lambda = 10) # gerar 10 valores a partir da distribuição de poisson com lambda = 10\n\n [1]  7 19  8  4 19  9  9  7  8  7\n\nrbinom(10, 10, 0.5) #distribuição binomial: total de sucessos em 10 rodadas de 10 jogadas de moedas  com 50% de probabilidade de sussesso (sussesso = tirar cara, por exemplo)\n\n [1] 7 7 6 5 6 4 9 5 5 3\nUtilizando valores aleatórios para simular um experimento. no exemplo abaixo (Figura 13.1).\n#gerar 150 valores aleatorios, 50 controle, 50 T1 e 50 T2\nComprimento &lt;- c(rnorm(50, 3,2), rnorm(50, 3,2), rnorm(50, 5,2))\nGrupo &lt;- rep(c(\"Controle\", \"T1\",\"T2\"), each = 50) \n\n#criar data frame\ndados &lt;- data.frame(Grupo, Comprimento)\n\n#gráfico\nboxplot(Comprimento ~ Grupo, data = dados)\n\n#anova com comparação entre grupos\ndados.aov &lt;- aov(Comprimento ~ Grupo, data = dados)\nsummary(dados.aov)\n\n             Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nGrupo         2  194.6   97.30   22.14 3.94e-09 ***\nResiduals   147  646.0    4.39                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nTukeyHSD(dados.aov)\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = Comprimento ~ Grupo, data = dados)\n\n$Grupo\n                 diff        lwr      upr     p adj\nT1-Controle 0.2011614 -0.7915298 1.193853 0.8809572\nT2-Controle 2.5104590  1.5177678 3.503150 0.0000000\nT2-T1       2.3092976  1.3166064 3.301989 0.0000005\n\n\n\n\n\n\n\n\nFigura 13.1: boxplot gerado a partir dos dados aleatórios",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Programação, strings e dados relacionais</span>"
    ]
  },
  {
    "objectID": "c13_Progr.html#fundamentos-de-programação",
    "href": "c13_Progr.html#fundamentos-de-programação",
    "title": "13  Programação, strings e dados relacionais",
    "section": "13.2 Fundamentos de programação",
    "text": "13.2 Fundamentos de programação\n\n13.2.1 Criando funções\nAs funções são tipos de objeto no R, como podemos observar ao verificar a classe de algumas funções utilizando class():\n\nclass(mean) # classe do objeto\n\n[1] \"function\"\n\nclass(lm)\n\n[1] \"function\"\n\nargs(lm) # argumentos da função\n\nfunction (formula, data, subset, weights, na.action, method = \"qr\", \n    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n    contrasts = NULL, offset, ...) \nNULL\n\n\nNão há uma função no R para calcular o erro padrão, então criaremos uma. Fórmula do erro padrão: \\[SE = \\sigma/\\sqrt N\\].\n\ndados &lt;- rnorm(20, mean = 0, sd = 1)\nsd(dados)\n\n[1] 1.298958\n\nsd(dados)/sqrt(length(dados)) # Fórmula para calcular o erro padrão\n\n[1] 0.2904559\n\n\nA partir da fórmula usada para calcular o erro padrão, vamos criar uma função para realizar o cálculo. Podemos criar funções utilizado function(). Vamos criar uma função para calcular o erro padrão. A função terá somente um argumento x, o qual será o vetor sobre o qual será calculado o erro padrão. Neste passo, criaremos uma função chamada ep(). Entre os ‘{}’ incluímos o que a função irá realizar:\n\nep &lt;- function(x){\n  sd(x)/sqrt(length(x))\n}\n\nep(dados)\n\n[1] 0.2904559\n\n\nAcima criamos a fução ep(x), que realizará o cálculo do erro padrão pela seguinte fórmula: sd(x)/sqrt(length(x).\n\n\n13.2.2 Condicionais: if() e else()\nOs condicionais if e else são usados para controlar o fluxo de execução do código com base em condições específicas.\n\nif: Executa um bloco de código se uma condição for verdadeira.\nelse: Pode ser usado em conjunto com if para executar um bloco de código alternativo caso a condição do if seja falsa.\n\nVamos criar uma função para descrever se um número é maior que 0 ou não. Nesta função, o argumento x será um valor numérico, e a função dirá se esse valor é maior que zero ou não. Desta forma ela seguirá a lógica:\n\nSe x &gt; 0 → imprimir(“O valor é maior que zero”)\nsenão → imprimir(“O valor é menor ou igual zero”)\n\nAssim, podemos escrever o código:\n\nmaiorquezero &lt;- function(x){\n  if (x &gt; 0){print(\"O valor é maior que zero\")}\n  else{print(\"O valor é menor ou igual a zero\")}\n}\n\nmaiorquezero(1)\n\n[1] \"O valor é maior que zero\"\n\nmaiorquezero(-1)\n\n[1] \"O valor é menor ou igual a zero\"\n\nmaiorquezero(0)\n\n[1] \"O valor é menor ou igual a zero\"\n\n\nVamos aperfeiçoar a função para diferenciar valores 0 de valores negativos. Para isso, podemos usar if() 3 vezes:\n\nmaiorquezero &lt;- function(x){\n  if (x&gt;0){print(\"O valor é maior que zero\")}\n  if (x==0){print(\"O valor é igual a zero\")}\n  if (x&lt;0){print(\"O valor é menor que zero\")}\n}\n\nmaiorquezero(1)\n\n[1] \"O valor é maior que zero\"\n\nmaiorquezero(-1)\n\n[1] \"O valor é menor que zero\"\n\nmaiorquezero(0)\n\n[1] \"O valor é igual a zero\"\n\n\nPara ilustrar o uso de condicionais, vamos aprimirar a função ep() que criamos. Ela não funciona direito se tivermos dados faltantes:\n\ndados.na &lt;- c(dados, NA)\ndados.na\n\n [1] -3.32314562  0.73757987  0.74957919 -0.29646092 -1.40441700 -0.61328784\n [7]  1.80066845  0.60608207 -0.19869613 -0.48870006  0.56443164  2.18348359\n[13] -1.38309710 -1.22406907  0.69985669 -0.06002146  1.10702320  0.39176396\n[19] -1.29842690  1.23749446          NA\n\nep(dados.na)\n\n[1] NA\n\n\nVamos incluir um condicional para aperfeiçoar a nossa função. O condicional permitirá que ela funcione diferente caso desejarmos que ela omita valores faltantes. Desta forma, abaixo nós:\n\nAdicionamos o argumento na.rm = FALSE à função. Desta forma, por padrão a função não irá remover valores faltantes, mas se colocarmos na.rm = TRUE, ela executará o condicional no qual ocorrerá a remoção dos valores faltantes.\nUtilizamos if e else para determinar como a função irá funcionar no caso de optarmos por na.rm = FALSEou na.rm = TRUE. Quando na.rm for TRUE, utilizaremos a função na.omit() para remover os valores faltantes.\n\n\nep &lt;- function(x, na.rm = FALSE){\n  if(na.rm == FALSE){sd(x)/sqrt(length(x))}\n  else{sd(x, na.rm == TRUE)/sqrt(length(na.omit(x)))}\n}\n\nep(dados.na)\n\n[1] NA\n\nep(dados.na, na.rm = TRUE)\n\n[1] 0.2904559\n\n\n\n\n13.2.3 Loops com for()\nA função for() repete um comando por um intervalo de valores. Ela permite executar um bloco de código repetidamente para cada elemento de uma sequência ou vetor. É uma estrutura de controle que permite iterar sobre elementos, aplicando uma operação específica a cada um deles. Vamos utilizá-la para calcular a soma das linhas do conjunto de dados iris (somente as variáveis numéricas).\n\niris.num &lt;- iris[,1:4] # somente os dados numéricos de iris\n\n  somas &lt;- vector() # cria um vetor numérico para salvar os valores.\n\nfor(i in 1:nrow(iris.num)){ # inicia o argumento for - para os valores de 1 ao número de linhas de iris\n  somas[i] &lt;- sum(iris.num[i,]) #cria cada valor do vetor iris com a soma dos valores da linha\n}\n\nsomas # ver os valores no objeto criado\n\n  [1] 10.2  9.5  9.4  9.4 10.2 11.4  9.7 10.1  8.9  9.6 10.8 10.0  9.3  8.5 11.2\n [16] 12.0 11.0 10.3 11.5 10.7 10.7 10.7  9.4 10.6 10.3  9.8 10.4 10.4 10.2  9.7\n [31]  9.7 10.7 10.9 11.3  9.7  9.6 10.5 10.0  8.9 10.2 10.1  8.4  9.1 10.7 11.2\n [46]  9.5 10.7  9.4 10.7  9.9 16.3 15.6 16.4 13.1 15.4 14.3 15.9 11.6 15.4 13.2\n [61] 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 15.7 14.2 15.2 14.8 14.9\n [76] 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 14.4 15.5 16.0 14.3 14.0 13.3\n [91] 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 11.7 13.9 18.1 15.5 18.1 16.6 17.5\n[106] 19.3 13.6 18.3 16.8 19.4 16.8 16.3 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7\n[121] 18.1 15.3 19.2 15.7 17.8 18.2 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7\n[136] 19.1 17.7 16.8 15.6 17.5 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8\n\n\nOs loops são relativamente lentos. Na maioria das veze podemos utilizar uma função vetorial ao invés de for(). Por exemplo, podemos utilizar apply() neste caso:\n\napply(iris.num, 1, sum)\n\n  [1] 10.2  9.5  9.4  9.4 10.2 11.4  9.7 10.1  8.9  9.6 10.8 10.0  9.3  8.5 11.2\n [16] 12.0 11.0 10.3 11.5 10.7 10.7 10.7  9.4 10.6 10.3  9.8 10.4 10.4 10.2  9.7\n [31]  9.7 10.7 10.9 11.3  9.7  9.6 10.5 10.0  8.9 10.2 10.1  8.4  9.1 10.7 11.2\n [46]  9.5 10.7  9.4 10.7  9.9 16.3 15.6 16.4 13.1 15.4 14.3 15.9 11.6 15.4 13.2\n [61] 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 15.7 14.2 15.2 14.8 14.9\n [76] 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 14.4 15.5 16.0 14.3 14.0 13.3\n [91] 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 11.7 13.9 18.1 15.5 18.1 16.6 17.5\n[106] 19.3 13.6 18.3 16.8 19.4 16.8 16.3 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7\n[121] 18.1 15.3 19.2 15.7 17.8 18.2 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7\n[136] 19.1 17.7 16.8 15.6 17.5 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8\n\n\nVamos utilizar o argumento for() para comparar uma curva da densidade da distribuição normal com a distribuição com diferentes graus de liberdade (1:50 gl); (Figura 13.2).\n\ncurve(dnorm(x), from=-4, to=4, col=\"red\", lwd=4)\nfor(gl in 1:50){\n  curve(dt(x, gl), add=TRUE, col=\"grey\")\n}\n?points\n\n\n\n\n\n\n\nFigura 13.2: Comparação da distribuição normal com distribuições t de diversos graus de liberdade\n\n\n\n\n\n\n\n13.2.4 Função return() e print()\nA função return( ) pode ser utilizada para retornar o resultado final de um loop. A função print( ) “imprime” os resultados intermediários de cada passo do loop.\n\nmult &lt;- function(x){\n  f &lt;- 1\n  for(i in 1:x){\n    f &lt;- f*i\n    print(f)}}\n\nmult2 &lt;- function(x){\n  f &lt;- 1\n  for(i in 1:x){\n    f &lt;- f*i}\n  return(f)}\n\nmult3 &lt;- function(x){\n  f &lt;- 1\n  for(i in 1:x){\n    f &lt;- f*i\n    return(f)}}\n\nmult(5) # retorna todos os valores gerados a cada iteração\n\n[1] 1\n[1] 2\n[1] 6\n[1] 24\n[1] 120\n\nmult2(5) # Retorna somente o último valor\n\n[1] 120\n\nmult3(5) # Retorna somente o primeiro valor, pois foi colocada antes de terminar a iteração\n\n[1] 1",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Programação, strings e dados relacionais</span>"
    ]
  },
  {
    "objectID": "c13_Progr.html#trabalhando-com-strings",
    "href": "c13_Progr.html#trabalhando-com-strings",
    "title": "13  Programação, strings e dados relacionais",
    "section": "14.1 Trabalhando com strings",
    "text": "14.1 Trabalhando com strings\nPodemos usar grep( ) para buscar um determinado elemento de texto em um vetor. Vamos procurar todas as espécies pertencentes ao gênero Pegoscapus na coluna “espécie” da nossa tabela id.novo.\n\nid.novo$Especie\n\n [1] \"Lutnes testaceus\"       \"Gonatocerus litoralis\"  \"Merostenus melinus\"    \n [4] \"Neomymar mirabilicorne\" \"Neomymar mirabilicorne\" \"Neomymar soror\"        \n [7] \"Neomymar soror\"         \"Copidosoma floridanum\"  \"Lutnes testaceus\"      \n[10] \"Gonatocerus litoralis\"  \"Merostenus melinus\"     \"Lutnes testaceus\"      \n[13] \"Gonatocerus litoralis\"  \"Merostenus melinus\"     \"Pegoscapus aerumnosus\" \n[16] \"Pegoscapus aerumnosus\"  \"Pegoscapus sp.4\"        \"Pegoscapus sp.4\"       \n[19] \"Pegoscapus sp.4\"        \"Physothorax sp.1\"       \"Pegoscapus tonduzi\"    \n[22] \"Pegoscapus tonduzi\"     \"Pegoscapus tonduzi\"     \"Pegoscapus tonduzi\"    \n\ngrep(\"Pegoscapus\", id.novo$Especie) # essas são as colunas das amostras que apresentam o gênero Pegoscapus\n\n[1] 15 16 17 18 19 21 22 23 24\n\nid.novo$Especie[grep(\"Pegoscapus\", id.novo$Especie)]\n\n[1] \"Pegoscapus aerumnosus\" \"Pegoscapus aerumnosus\" \"Pegoscapus sp.4\"      \n[4] \"Pegoscapus sp.4\"       \"Pegoscapus sp.4\"       \"Pegoscapus tonduzi\"   \n[7] \"Pegoscapus tonduzi\"    \"Pegoscapus tonduzi\"    \"Pegoscapus tonduzi\"   \n\nPegoscapus &lt;- id.novo[grep(\"Pegoscapus\", id.novo$Especie),] # todas as linhas que apresentam Pegoscapus\nPegoscapus\n\n   Amostra   Familia               Especie Amostra Dia Mês  Ano       Pais\n15   AM005 Agaonidae Pegoscapus aerumnosus   AM005   6   4 2019     Brasil\n16   AM006 Agaonidae Pegoscapus aerumnosus   AM006  12   8 2019     Brasil\n17   AM007 Agaonidae       Pegoscapus sp.4   AM007  12   8 2019     Brasil\n18   AM008 Agaonidae       Pegoscapus sp.4   AM008  12   8 2019     Brasil\n19   AM009 Agaonidae       Pegoscapus sp.4   AM009  12   8 2019     Brasil\n21   AM012 Agaonidae    Pegoscapus tonduzi   AM012  16   2 2020     Brasil\n22   AM023 Agaonidae    Pegoscapus tonduzi   AM023  18   6 2019 Costa Rica\n23   AM024 Agaonidae    Pegoscapus tonduzi   AM024  18   6 2019 Costa Rica\n24   AM025 Agaonidae    Pegoscapus tonduzi   AM025  18   6 2019 Costa Rica\n     Prov_Est\n15      Goiás\n16      Goiás\n17      Goiás\n18      Goiás\n19      Goiás\n21  São Paulo\n22 Puntarenas\n23   Alajuela\n24   Alajuela\n\n\nVamos pegar somente as primeiras letras do código da amostra (AMXXX) ou somente o número com strtrim( ) no data frame Pegoscapus:\n\nPegoscapus$Amostra\n\n[1] \"AM005\" \"AM006\" \"AM007\" \"AM008\" \"AM009\" \"AM012\" \"AM023\" \"AM024\" \"AM025\"\n\nstrtrim(Pegoscapus$Amostra, 2) # Pegar somente os dois primeiros elementos\n\n[1] \"AM\" \"AM\" \"AM\" \"AM\" \"AM\" \"AM\" \"AM\" \"AM\" \"AM\"\n\n#install.packages(\"stringr) # pacote para trabalhar com strings\nlibrary(stringr)\nstr_sub(Pegoscapus$Amostra, start = -3) # Deixa somente os últimos 3 caracteres\n\n[1] \"005\" \"006\" \"007\" \"008\" \"009\" \"012\" \"023\" \"024\" \"025\"\n\n\nVamos separar somente os nomes dos gêneros e criar uma nova coluna com eles. Podemos fazer isso com a função str_split( ):\n\nseparar &lt;- str_split(id.novo$Especie, \" \") # separa os strigs pelo elemento 'espaço' (\" \")\n\n# pegar somente os primeiros elementos da lista\nGenero &lt;- unlist(lapply(separar, `[[`, 1))\n\n# Criar novo data frame com id.novo e a coluna Genero\nid.novo.gen &lt;- data.frame(id.novo,Genero)\nhead(id.novo.gen)\n\n  Amostra    Familia                Especie Amostra.1 Dia Mês  Ano   Pais\n1   AM001 Eupelmidae       Lutnes testaceus     AM001   1   3 2019 Brasil\n2   AM001  Mymaridae  Gonatocerus litoralis     AM001   1   3 2019 Brasil\n3   AM001 Eupelmidae     Merostenus melinus     AM001   1   3 2019 Brasil\n4   AM005  Mymaridae Neomymar mirabilicorne     AM005   6   4 2019 Brasil\n5   AM005  Mymaridae Neomymar mirabilicorne     AM005   6   4 2019 Brasil\n6   AM005  Mymaridae         Neomymar soror     AM005   6   4 2019 Brasil\n  Prov_Est      Genero\n1    Goiás      Lutnes\n2    Goiás Gonatocerus\n3    Goiás  Merostenus\n4    Goiás    Neomymar\n5    Goiás    Neomymar\n6    Goiás    Neomymar",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Programação, strings e dados relacionais</span>"
    ]
  },
  {
    "objectID": "c13_Progr.html#trabalhando-com-dados-relacionais-e-filtros-no-tidyverse",
    "href": "c13_Progr.html#trabalhando-com-dados-relacionais-e-filtros-no-tidyverse",
    "title": "13  Programação, strings e dados relacionais",
    "section": "14.2 Trabalhando com dados relacionais e filtros no tidyverse",
    "text": "14.2 Trabalhando com dados relacionais e filtros no tidyverse\nPacotes como o dplyr apresentam diversas funções para manipular conjuntos de dados. Vamos juntar as tabelas id e amostras pela coluna Amostra, e depois filtrar somente as amostras de Goiás:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nid %&gt;%\n  left_join(amostras, by = \"Amostra\") %&gt;%\n  filter(Prov_Est == \"Goiás\")\n\n# A tibble: 13 × 8\n   Amostra Familia    Especie                  Dia   Mês   Ano Pais   Prov_Est\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   \n 1 AM001   Eupelmidae Lutnes testaceus           1     3  2019 Brasil Goiás   \n 2 AM001   Mymaridae  Gonatocerus litoralis      1     3  2019 Brasil Goiás   \n 3 AM001   Eupelmidae Merostenus melinus         1     3  2019 Brasil Goiás   \n 4 AM005   Mymaridae  Neomymar mirabilicorne     6     4  2019 Brasil Goiás   \n 5 AM005   Mymaridae  Neomymar mirabilicorne     6     4  2019 Brasil Goiás   \n 6 AM005   Mymaridae  Neomymar soror             6     4  2019 Brasil Goiás   \n 7 AM005   Mymaridae  Neomymar soror             6     4  2019 Brasil Goiás   \n 8 AM005   Agaonidae  Pegoscapus aerumnosus      6     4  2019 Brasil Goiás   \n 9 AM006   Agaonidae  Pegoscapus aerumnosus     12     8  2019 Brasil Goiás   \n10 AM007   Agaonidae  Pegoscapus sp.4           12     8  2019 Brasil Goiás   \n11 AM008   Agaonidae  Pegoscapus sp.4           12     8  2019 Brasil Goiás   \n12 AM009   Agaonidae  Pegoscapus sp.4           12     8  2019 Brasil Goiás   \n13 AM009   Torymidae  Physothorax sp.1          12     8  2019 Brasil Goiás",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Programação, strings e dados relacionais</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html",
    "href": "c14_Datasets.html",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "",
    "text": "14.1 pinguins\nVersão simplificada do conjunto de dados de pinguins das ilhas Palmer (Gorman et al., 2014; Horst et al., 2020).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#pinguins",
    "href": "c14_Datasets.html#pinguins",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "",
    "text": "Gorman, K.B., Williams, T.D. & Fraser, W.R. (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis) A. Chiaradia (Ed). PLoS ONE 9, e90081. https://doi.org/10.1371/journal.pone.0090081\n\n\nHorst, A.M., Hill, A.P. & Gorman, K.B. (2020) palmerpenguins: Palmer Archipelago (Antarctica) penguin data.\n\n\nMcDonald (2014) Handbook of Biological Statistics. Third.\n\n\nWalker, T.J. (1962) The Taxonomy and Calling Songs of United States Tree Crickets (Orthoptera: Gryllidae: Oecanthinae). I. The Genus Neoxabea and the niveus and varicornis Groups of the Genus Oecanthus1. Annals of the Entomological Society of America 55, 303–322. https://doi.org/10.1093/aesa/55.3.303",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "czz_Referencias.html",
    "href": "czz_Referencias.html",
    "title": "Referências",
    "section": "",
    "text": "Aho, K., Derryberry, D., & Peterson, T. (2014). Model selection for\necologists: the worldviews of AIC and BIC. Ecology,\n95(3), 631–636. https://doi.org/10.1890/13-1452.1\n\n\nBehrens, J. T. (1997). Principles and procedures of exploratory data\nanalysis. Psychological Methods, 2(2), 131160. https://doi.org/10.1037/1082-989X.2.2.131\n\n\nCrawley, M. J. (2013). The R book (Second edition). Wiley.\n\n\nDa Silva, R. S., Souza, T. G., Paterno, G. B., Provete, D. B., &\nVancine, M. H. (2022). Análises ecológicas no r (Primeira\nedição). Nupeea.\n\n\nErnest, M., Brown, J., Valone, T., & White, E. P. (2020). Portal\nproject teaching database. https://doi.org/10.6084/M9.FIGSHARE.1314459.V10\n\n\nFarache, F. H. A., Cruaud, A., Rasplus, J.-Y., Cerezini, M. T., Rattis,\nL., Kjellberg, F., & Pereira, R. A. S. (2018). Insights into the\nstructure of plant-insect communities: Specialism and generalism in a\nregional set of non-pollinating fig wasp communities. Acta\nOecologica, 90, 4959. https://doi.org/10.1016/j.actao.2018.02.006\n\n\nFaraway, J. J. (2009). Linear Models with R. Boca Raton.\n\n\nGorman, K. B., Williams, T. D., & Fraser, W. R. (2014). Ecological\nSexual Dimorphism and Environmental Variability within a Community of\nAntarctic Penguins (Genus Pygoscelis). PLoS ONE, 9(3),\ne90081. https://doi.org/10.1371/journal.pone.0090081\n\n\nGotelli, N. J. (2007). Ecologia (3. ed). Ed. Planta.\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de\nestatística em ecologia. Artmed.\n\n\nHorst, A. M., Hill, A. P., & Gorman, K. B. (2020).\nPalmerpenguins: Palmer archipelago (antarctica) penguin data.\nhttps://doi.org/10.5281/zenodo.3960218\n\n\nJones, E., Harden, S., & Crawley, M. J. (2022). The r book\n(Third edition). Wiley.\n\n\nLepš, J., & Šmilauer, P. (2020). Biostatistics with r: An\nintroductory guide for field biologists. Cambridge University\nPress.\n\n\nMagnusson, W. E. (2003). Estatistica Sem Matematica. Não\ndefinido.\n\n\nMcDonald. (2014). Handbook of biological statistics (Third).\n\n\nMello, M. P., & Peternelli, L. A. (2013). Conhecendo o r: Uma\nvisão mais que estatística. Editora UFV.\n\n\nTonhasca Jr, A. (1991). The three \"capital\nsins\" of statistics used in biology. Ciência e\nCultura, 43(6), 417422. message:%3C1527538750.417090.1562784042935@mail.yahoo.com%3E\n\n\nTsagris, M., & Pandis, N. (2021). Normality test: Is it really\nnecessary? American Journal of Orthodontics and Dentofacial\nOrthopedics, 159(4), 548–549. https://doi.org/10.1016/j.ajodo.2021.01.003\n\n\nVenables, W. N., Smith, D. M., & R Core Team. (2020). An\nintroduction to r. https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf\n\n\nWalker, T. J. (1962). The Taxonomy and Calling Songs of United States\nTree Crickets (Orthoptera: Gryllidae: Oecanthinae). I. The Genus\nNeoxabea and the niveus and varicornis Groups of the Genus Oecanthus1.\nAnnals of the Entomological Society of America, 55(3),\n303–322. https://doi.org/10.1093/aesa/55.3.303\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\ndata science: import, tidy, transform, visualize, and model data\n(2nd edition). O’Reilly Media, Inc.\n\n\nWilkinson, L., & Wills, G. (2005). The grammar of graphics\n(2nd ed). Springer.\n\n\nZar, J. H. (2010). Biostatistical analysis (5th ed).\nPrentice-Hall/Pearson.",
    "crumbs": [
      "Referências"
    ]
  },
  {
    "objectID": "c03_Import.html#dados-faltantes",
    "href": "c03_Import.html#dados-faltantes",
    "title": "3  Conjuntos de dados e importação",
    "section": "3.3 Dados faltantes",
    "text": "3.3 Dados faltantes\nDados faltantes são valores ausentes em um conjunto de dados, que podem ocorrer por diversas razões, como erros na coleta de dados, falhas técnicas, respostas não fornecidas por participantes em uma pesquisa, entre outros. Eles podem ser representados por células vazias em uma planilha ou por algum termo (por exemplo, “NA”). deve-se ter cuidado ao importar esses dados no R para que sejam lidos como dados faltantes e nào como texto.\nVamos ler a planilha dados_problemas. Se você observar o conjunto de dados antes de importar, verá que a coluna diâmetro apresenta dados faltantes representados por uma célula vazia, enquanto a coluna sementes apresenta dados faltantes representados pela sigla “NA”:\n\ndados_prob &lt;- read_excel(\"dados_R.xlsx\", sheet = \"dados_problemas\")\nstr(dados_prob)\n\ntibble [60 × 3] (S3: tbl_df/tbl/data.frame)\n $ especie : chr [1:60] \"citrif\" \"citrif\" \"citrif\" \"citrif\" ...\n $ diametro: num [1:60] 1.58 1.67 1.6 1.43 1.49 1.35 1.42 1.4 1.51 1.53 ...\n $ sementes: chr [1:60] \"220\" \"276\" \"180\" \"112\" ...\n\n\nRepare que a coluna sementes, que deveria ter sido numérica, apareceu como uma coluna de caracteres.\nVamos observar os valores com mais detalhes:\n\ndados_prob$sementes\n\n [1] \"220\" \"276\" \"180\" \"112\" \"172\" \"200\" \"176\" \"196\" \"128\" \"252\" \"164\" \"176\"\n[13] \"188\" \"192\" \"220\" \"200\" \"216\" \"244\" \"228\" \"208\" \"42\"  \"36\"  \"52\"  \"37\" \n[25] \"30\"  \"16\"  \"13\"  \"18\"  \"16\"  \"31\"  \"16\"  \"4\"   \"16\"  \"12\"  \"47\"  \"20\" \n[37] \"31\"  \"13\"  \"21\"  \"21\"  \"204\" \"200\" \"156\" \"224\" \"220\" \"200\" \"216\" \"176\"\n[49] \"216\" \"420\" \"180\" \"184\" \"152\" \"NA\"  \"192\" \"188\" \"304\" \"344\" \"NA\"  \"340\"\n\ndados_prob$diametro\n\n [1]  1.58  1.67  1.60  1.43  1.49  1.35  1.42  1.40  1.51  1.53  1.42  1.55\n[13]    NA  1.37  1.55  1.34  1.48  1.49  1.55  1.53  0.66  0.82  0.76  0.77\n[25]  0.74  0.81  0.85  0.78  0.73  0.81  0.76  0.81  0.81  0.71  0.77 79.00\n[37]  0.79  0.76  0.76  0.98  2.42  2.29  2.38  2.26  2.40  2.43  2.33  2.30\n[49]  2.25  2.51  2.01  2.18  2.26  2.30  2.21  2.25  2.28  2.14  2.15  2.10\n\n\nObserve que na coluna sementes alguns valores apareceram como “NA” escrito. Isso ocorre por que na planilha foi utilizado o termo “NA” para indicar dados faltantes. Nesse caso, o “NA” aparece entre aspas. Observe que na coluna diametro, há também um dado faltante, mas ele foi interpretado de forma correta.\nPodemos converter a coluna em numérica da seguinte forma:\n\ndados_prob$sementes &lt;- as.numeric(dados_prob$sementes)\n\nWarning: NAs introduced by coercion\n\ndados_prob$sementes\n\n [1] 220 276 180 112 172 200 176 196 128 252 164 176 188 192 220 200 216 244 228\n[20] 208  42  36  52  37  30  16  13  18  16  31  16   4  16  12  47  20  31  13\n[39]  21  21 204 200 156 224 220 200 216 176 216 420 180 184 152  NA 192 188 304\n[58] 344  NA 340\n\n\nAo fazer isso, os valores que não eram numéricos foram transformados em valores faltantes por coerção.\n\nPara indicar para a função read_excel() que os dados faltantes também são representados pelo texto “NA”, podemos importar da seguinte forma:\n\ndados_prob &lt;- read_excel(\"dados_R.xlsx\", sheet = \"dados_problemas\", na = \"NA\")\ndados_prob$diametro\n\n [1]  1.58  1.67  1.60  1.43  1.49  1.35  1.42  1.40  1.51  1.53  1.42  1.55\n[13]    NA  1.37  1.55  1.34  1.48  1.49  1.55  1.53  0.66  0.82  0.76  0.77\n[25]  0.74  0.81  0.85  0.78  0.73  0.81  0.76  0.81  0.81  0.71  0.77 79.00\n[37]  0.79  0.76  0.76  0.98  2.42  2.29  2.38  2.26  2.40  2.43  2.33  2.30\n[49]  2.25  2.51  2.01  2.18  2.26  2.30  2.21  2.25  2.28  2.14  2.15  2.10\n\ndados_prob$sementes\n\n [1] 220 276 180 112 172 200 176 196 128 252 164 176 188 192 220 200 216 244 228\n[20] 208  42  36  52  37  30  16  13  18  16  31  16   4  16  12  47  20  31  13\n[39]  21  21 204 200 156 224 220 200 216 176 216 420 180 184 152  NA 192 188 304\n[58] 344  NA 340\n\n\nOs valores faltantes podem causar problemas na hora de analisar os dados. Algumas funções podem apresentar argumentos para remover os NAs ao calcular a média:\n\nmean(dados_prob$sementes) #Resultado: NA\n\n[1] NA\n\nmean(dados_prob$sementes, na.rm = TRUE) #Rremove o valor faltante e calcula a média\n\n[1] 147.5172\n\n\nÉ possível também remover todas as observações que apresentam dados faltantes. Deve-se fazer isso com cautela, levando em conta a intenção de omitir os dados faltantes, pois ao fazer isso podemos remover informação de outras colunas que não são dados faltantes:\n\ndados_prob_naomit &lt;- na.omit(dados_prob)\ndados_prob_naomit\n\n# A tibble: 57 × 3\n   especie diametro sementes\n   &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n 1 citrif      1.58      220\n 2 citrif      1.67      276\n 3 citrif      1.6       180\n 4 citrif      1.43      112\n 5 citrif      1.49      172\n 6 citrif      1.35      200\n 7 citrif      1.42      176\n 8 citrif      1.4       196\n 9 citrif      1.51      128\n10 citrif      1.53      252\n# ℹ 47 more rows\n\n\nAqui, nós criamos um novo objeto chamado dados_prob_naomit, que exclui todas as linhas que apresentam dados daltantes.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos de dados e importação</span>"
    ]
  },
  {
    "objectID": "c03_Import.html#problemas-de-digitação-dos-valores",
    "href": "c03_Import.html#problemas-de-digitação-dos-valores",
    "title": "3  Conjuntos de dados e importação",
    "section": "3.4 Problemas de digitação dos valores",
    "text": "3.4 Problemas de digitação dos valores\n\n3.4.1 Erros de digitação de valores numéricos\nDevido à problemas de digitação, podemos ver alguns problemas nos valores. Observe por exemplo o diâmetro dos figos:\n\nsummary(dados_prob$diametro)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  0.660   0.810   1.510   2.841   2.230  79.000       1 \n\n\nPodemos observar que o valor máximo destoa das outras estatísticas descritivas. Vamos fazer um gráfico simples para ilustrar isso. Obs.: Estatísticas descritivas e análise gráfica são discutidos nos próximos 2 capítulos.\n\nplot(dados_prob$diametro)\n\n\n\n\n\n\n\n\nEste gráfico de dispersão mostra os valores de diâmetro em função de um índice (o número da linha da observação). Vemos que entre o valor 30 e 40, apareceu um valor extremo:\n\nwhich(dados_prob$diametro &gt;70)\n\n[1] 36\n\ndados_prob$diametro[dados_prob$diametro &gt;70]\n\n[1] NA 79\n\n\ncom a função which(), vimos que o elemento 36 foi o valor que foi maior que 70. Nesse caso, ele foi digitado errado, e foi digitado o número 79 em vez de 0.79.\n\n\n3.4.2 Erros de digitação em caracteres\nVamos observar as abreviações de nomes de espécies:\n\ntable(dados_prob$especie)\n\n\ncitrif  obfol  Obfol   obus \n    20     19      1     20 \n\nunique(dados_prob$especie)\n\n[1] \"citrif\" \"obus\"   \"obfol\"  \"Obfol\" \n\n\nTanto com a função table() como a função unique() demonstratam que obfol parece ter sido digitado erroneamente com maiúsculo. No caso de table(), ainda podemos ver que a digitação errônea aconteceu somente uma vez.\nA correção pode ser feita diretamente no R, ou pode ser realizada no aplicativo de edição de planilhas.\n\n\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science: import, tidy, transform, visualize, and model data (2nd edition). O’Reilly Media, Inc.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos de dados e importação</span>"
    ]
  },
  {
    "objectID": "c04_EstDescritiva.html#utilizando-o-tidyverse-para-calcular-estatísticas-descritivas",
    "href": "c04_EstDescritiva.html#utilizando-o-tidyverse-para-calcular-estatísticas-descritivas",
    "title": "4  Estatísticas descritivas",
    "section": "4.4 Utilizando o tidyverse para calcular estatísticas descritivas",
    "text": "4.4 Utilizando o tidyverse para calcular estatísticas descritivas\nO tidyverse é um conjunto de pacotes versátil para ciência de dados e apresenta ferramentas sofixticadas para calcular estatísticas descritivas (Wickham et al., 2023). Para mais informações, consulte o capítulo “Introdução ao Tidyverse”.\n\n\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science: import, tidy, transform, visualize, and model data (2nd edition). O’Reilly Media, Inc.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estatísticas descritivas</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análise de Dados em Biodiversidade: uma Introdução Utilizando o R",
    "section": "",
    "text": "Prefácio\nEsta apostila tem por objetivo servir de referência prática para a disciplina “Estatística Aplicada à Biodiversidade”, do IF Goiano Campus Rio Verde. Nela, estão inclusas as instruções para a análise dos dados utilizando o ambiente R. De forma a familiarizar-se com o conteúdo teórico, utilize as referências indicadas (Gotelli & Ellison, 2016; Magnusson, 2003; Zar, 2010). Para documentos mais extensivos sobre análise estatística em R, verifique as referências Lepš & Šmilauer (2020), Venables et al. (2020), Jones et al. (2022) e (Da Silva et al., 2022).\nOs códigos digitados em R são exibidos destacados no texto e, quando pertinente, os resultados são apresentados logo abaixo do código, como no exemplo abaixo:\n\nseq(1:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nEsta apostila foi escrita em Quarto. Para saberm mais sobre a paltaforma, visite: https://quarto.org/docs/books.\n\n\n\n\nDa Silva, R. S., Souza, T. G., Paterno, G. B., Provete, D. B., & Vancine, M. H. (2022). Análises ecológicas no R (Primeira edição). Nupeea.\n\n\nGotelli, N. J., & Ellison, A. M. (2016). Princípios de estatística em ecologia. Artmed.\n\n\nJones, E., Harden, S., & Crawley, M. J. (2022). The R book (Third edition). Wiley.\n\n\nLepš, J., & Šmilauer, P. (2020). Biostatistics with R: an introductory guide for field biologists. Cambridge University Press.\n\n\nMagnusson, W. E. (2003). Estatistica Sem Matematica. Não definido.\n\n\nVenables, W. N., Smith, D. M., & R Core Team. (2020). An Introduction to R. https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf\n\n\nZar, J. H. (2010). Biostatistical analysis (5th ed). Prentice-Hall/Pearson.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "c14_Datasets.html#dados_problemas",
    "href": "c14_Datasets.html#dados_problemas",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.2 dados_problemas",
    "text": "14.2 dados_problemas\nConjunto de dados incluindo pequenos problemas de digitação e valores faltantes.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#artropodes",
    "href": "c14_Datasets.html#artropodes",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.3 artropodes",
    "text": "14.3 artropodes\nAbundância de artrópodes em ambiente aberto (matriz) e em fragmento florestal",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#galhadores",
    "href": "c14_Datasets.html#galhadores",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.4 galhadores",
    "text": "14.4 galhadores\nTamanho do corpo de galhadores e parasitas associados a diferentes espécies de plantas",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#oviposicao",
    "href": "c14_Datasets.html#oviposicao",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.5 oviposicao",
    "text": "14.5 oviposicao\nTamanho do ovipositor de vespas associadas a espécies de figos hospedeiros",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#figos",
    "href": "c14_Datasets.html#figos",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.6 figos",
    "text": "14.6 figos\nQuantidade de polinizadores, sementes e não-polinizadores (galhadores ou parasitas) associados a figos",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#figos_comp",
    "href": "c14_Datasets.html#figos_comp",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.7 figos_comp",
    "text": "14.7 figos_comp\nDiâmetro e quantidade de sementes de diferentes espécies de Ficus",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#grilos",
    "href": "c14_Datasets.html#grilos",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.8 grilos",
    "text": "14.8 grilos\nNúmero de pulsos em relação à temperatura em grilos pertencentes a duas espécies (McDonald, 2014; Walker, 1962).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#atividade",
    "href": "c14_Datasets.html#atividade",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.9 atividade",
    "text": "14.9 atividade\nConjunto de dados simulado, descrevendo a movimentação e alimentação de machos e fêmeas de insetos sob 2 tratamentos.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#riqueza",
    "href": "c14_Datasets.html#riqueza",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.10 riqueza",
    "text": "14.10 riqueza\nConjunto de dados simulado, riqueza de espécies em relação à biomassa e luminosidade (normalizadas).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#pres_aus",
    "href": "c14_Datasets.html#pres_aus",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.11 pres_aus",
    "text": "14.11 pres_aus\nConjunto de dados simulado, presença de ausência de uma espécie em relação à área de um fragmento e da distância do fragmento em relação à área florestal maior mais próxima.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#comunidades",
    "href": "c14_Datasets.html#comunidades",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.12 comunidades",
    "text": "14.12 comunidades\nAbundâncias de espécies de vespas de figo em difeerntes hospedeiros coletados em duas localidades. Baseado em dados do trabalho Farache et al. (2018).\nConjunto de dados simulado, amostras com um identificador (chave primária), incluindo local e data de coleta",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#amostras",
    "href": "c14_Datasets.html#amostras",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.13 amostras",
    "text": "14.13 amostras\nConjunto de dados simulado, amostras com um identificador (chave primária), incluindo local e data de coleta",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  },
  {
    "objectID": "c14_Datasets.html#id",
    "href": "c14_Datasets.html#id",
    "title": "14  Conjuntos de dados utilizados neste trabalho",
    "section": "14.13 id",
    "text": "14.13 id\nConjunto de dados simulado, identificação de espécimes coletados na tabela “amostras”, incluindo o identificador (chave estrangeira)\n\n\n\n\nFarache, F. H. A., Cruaud, A., Rasplus, J.-Y., Cerezini, M. T., Rattis, L., Kjellberg, F., & Pereira, R. A. S. (2018). Insights into the structure of plant-insect communities: Specialism and generalism in a regional set of non-pollinating fig wasp communities. Acta Oecologica, 90, 4959. https://doi.org/10.1016/j.actao.2018.02.006\n\n\nGorman, K. B., Williams, T. D., & Fraser, W. R. (2014). Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE, 9(3), e90081. https://doi.org/10.1371/journal.pone.0090081\n\n\nHorst, A. M., Hill, A. P., & Gorman, K. B. (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. https://doi.org/10.5281/zenodo.3960218\n\n\nMcDonald. (2014). Handbook of Biological Statistics (Third).\n\n\nWalker, T. J. (1962). The Taxonomy and Calling Songs of United States Tree Crickets (Orthoptera: Gryllidae: Oecanthinae). I. The Genus Neoxabea and the niveus and varicornis Groups of the Genus Oecanthus1. Annals of the Entomological Society of America, 55(3), 303–322. https://doi.org/10.1093/aesa/55.3.303",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conjuntos de dados utilizados neste trabalho</span>"
    ]
  }
]